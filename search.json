[{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"某周写题报告","url":"/posts/a443d63f/","content":"\n把某周做过的题稍微整理了一下，主要是DP，方便随时复习，也方便后人踩坑。\n\n\n\n\n1 完全背包 · 洛谷 P1616 疯狂的采药思路把「时间」看成背包容量，「价值」就是药草收益。每种药草可以无限次采集 ⇒ 完全背包。\n状态转移  \ndp[j] = max(dp[j], dp[j - h[i]] + w[i])\n\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;typedef long long ll;int h[N], w[N];const int M = 1e7 + 10;ll dp[M];int main()&#123;    int t, m;    scanf(&quot;%d%d&quot;, &amp;t, &amp;m);    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;h[i], &amp;w[i]);    &#125;    for (int i = 1; i &lt;= m; i++)    &#123;        for (int j = h[i]; j &lt;= t; j++)        &#123;            dp[j] = max(dp[j - h[i]] + w[i], dp[j]);        &#125;    &#125;    printf(&quot;%lld\\n&quot;, dp[t]);    return 0;&#125;\n\n\n2 混合背包 · 洛谷 P1833 樱花思路题目同时出现 01、多重、完全三种背包。\n\np[i] == 0 → 完全背包\np[i] &gt; 0  → 01 &#x2F; 多重背包\n\n状态转移完全背包：正序多重背包：拆成 01 后逆序\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;int t[N], w[N], p[N];int dp[1008];int main()&#123;    int h1, h2, m1, m2;    scanf(&quot;%d:%d %d:%d&quot;, &amp;h1, &amp;m1, &amp;h2, &amp;m2);    int n;    scanf(&quot;%d&quot;, &amp;n);    int ans = (m2 - m1) + (h2 - h1) * 60;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;t[i], &amp;w[i], &amp;p[i]);    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        if (p[i] == 0) //完全背包        &#123;            for (int j = t[i]; j &lt;= ans; j++)            &#123;                dp[j] = max(dp[j - t[i]] + w[i], dp[j]);            &#125;        &#125;        else //多重背包和01背包        &#123;            for (int k = 1; k &lt;= p[i]; k++)            &#123;                for (int j = ans; j &gt;= k * t[i]; j--)                &#123;                    dp[j] = max(dp[j - t[i]] + w[i], dp[j]);                &#125;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[ans]);    return 0;&#125;\n\n\n3 二维背包 · 洛谷 P1855 榨取kkksc03思路背包有两个限制维度：时间 &amp; 金钱 ⇒ 二维 01 背包。\n状态转移\ndp[j][k] = max(dp[j][k], dp[j - a[i]][k - b[i]] + 1)\n\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;int a[108], b[108];int dp[300][300];int main()&#123;    int n, m, t;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = m; j &gt;= a[i]; j--)        &#123;            for (int k = t; k &gt;= b[i]; k--)            &#123;                dp[j][k] = max(dp[j][k], dp[j - a[i]][k - b[i]] + 1);            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[m][t]);    return 0;&#125;\n\n\n4 分组背包 · 洛谷 P1757 通天之分组背包思路物品分多组，每组最多选一个 ⇒ 经典分组背包。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;int cnt[N];int dp[N];int a[N], b[N];int vis[N][N];int main()&#123;    int m, n;    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);    int ans;    int maxn = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;ans);        ++cnt[ans];        vis[ans][cnt[ans]] = i;        maxn = max(maxn, ans);    &#125;    for (int i = 1; i &lt;= maxn; i++)    &#123;        for (int j = m; j &gt;= 0; j--)        &#123;            for (int k = 1; k &lt;= cnt[i]; k++)            &#123;                if (j &gt;= a[vis[i][k]])                &#123;                    dp[j] = max(dp[j], dp[j - a[vis[i][k]]] + b[vis[i][k]]);                &#125;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[m]);    return 0;&#125;\n\n\n5 带附件的 01 背包 · 洛谷 P1064 [NOIP2006 提高组] 金明的预算方案思路每个主件最多带 2 个附件，决策从 2 种变成 5 种：不选、只选主件、主件 + 附件1、主件 + 附件2、主件 + 全部附件。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e4 + 10;int dpmainv[N], dpmainw[N];int dpannexv[N][3], dpannexw[N][3];int cnt[N];int dp[N];int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int a, b, q;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;q);        if (q == 0)        &#123;            dpmainv[i] = a;            dpmainw[i] = a * b;        &#125;        else        &#123;            cnt[q]++;            dpannexv[q][cnt[q]] = a;            dpannexw[q][cnt[q]] = a * b;        &#125;    &#125;    for (int i = 1; i &lt;= m; i++)    &#123;        for (int j = n; j &gt;= dpmainv[i] &amp;&amp; dpmainv[i] &gt; 0; j--)        &#123;            dp[j] = max(dp[j], dp[j - dpmainv[i]] + dpmainw[i]);            if (j &gt;= dpmainv[i] + dpannexv[i][1])            &#123;                dp[j] = max(dp[j], dp[j - dpmainv[i] - dpannexv[i][1]] + dpmainw[i] + dpannexw[i][1]);            &#125;            if (j &gt;= dpmainv[i] + dpannexv[i][2])            &#123;                dp[j] = max(dp[j], dp[j - dpmainv[i] - dpannexv[i][2]] + dpmainw[i] + dpannexw[i][2]);            &#125;            if (j &gt;= dpmainv[i] + dpannexv[i][1] + dpannexv[i][2])            &#123;                dp[j] = max(dp[j], dp[j - dpmainv[i] - dpannexv[i][1] - dpannexv[i][2]] + dpmainw[i] + dpannexw[i][1] + dpannexw[i][2]);            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[n]);    return 0;&#125;\n\n\n6 树形 DP · 洛谷 P1352 没有上司的舞会思路树上做 01 背包：\n\ndp[u][0] 不参加，儿子可选可不选\ndp[u][1] 参加，儿子不能参加\n\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e3 + 10;int a[N];int dp[N][2];int vis[N];vector&lt;int&gt; v[N];void dfs(int ans)&#123;    dp[ans][1] = a[ans];    for (int i = 0; i &lt; v[ans].size(); i++)    &#123;        int cnt = v[ans][i];        dfs(cnt);                                  //往下遍历        dp[ans][0] += max(dp[cnt][0], dp[cnt][1]); //他的下属参加还是不参加        dp[ans][1] += dp[cnt][0];                  //此时下属不能参加    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    int p, q;    for (int i = 1; i &lt;= n - 1; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;p, &amp;q);        v[q].push_back(p);        vis[p] = 1; //把职员标记上    &#125;    int ans = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        if (vis[i] == 0) //找最高职位，也就是树的根        &#123;            ans = i;            break;        &#125;    &#125;    dfs(ans);    printf(&quot;%d\\n&quot;, max(dp[ans][0], dp[ans][1]));    return 0;&#125;\n\n\n7 区间 DP · 能量项链思路环形合并石子模板：枚举长度 → 枚举左端点 → 枚举断点。\n代码\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 2e2 + 10;int a[N];int dp[N][N];int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        a[i + n] = a[i];    &#125;    // 2 3 5 10 2 3 5 10    //还是环形石子问题    for (int len = 3; len &lt;= n + 1; len++) //最少要三个值才能聚合两个珠子，但最后一个值最后还会用到    &#123;        for (int l = 1; l + len - 1 &lt;= 2 * n; l++)        &#123;            int r = l + len - 1;            for (int k = l + 1; k &lt; r; k++) //由于每颗珠子分首尾，所以k最小也得是l+1            &#123;                dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r] + a[l] * a[k] * a[r]); //由于k位置这个元素会重复用到，所以不用加一！！！            &#125;        &#125;    &#125;    int maxn = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        maxn = max(maxn, dp[i][n + i]);        // printf(&quot;%d\\n&quot;, dp[i][i + n]);    &#125;    printf(&quot;%d\\n&quot;, maxn);    return 0;&#125;\n\n\n8 第 k 优解 · HDU 2639思路在 01 背包基础上多开一维 dp[j][k] 记录体积为 j 时的前 k 大值。\n核心技巧每次用归并排序思想把两条链（选&#x2F;不选）的前 k 大合并。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 10;int dp[N][N];int a[108], b[108];int c[108], d[108];int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    &#123;        memset(dp, 0, sizeof(dp));        memset(c, 0, sizeof(c));        memset(d, 0, sizeof(d));        int n, v, p;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;p);        for (int i = 1; i &lt;= n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;a[i]);        &#125;        for (int i = 1; i &lt;= n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;b[i]);        &#125;        for (int i = 1; i &lt;= n; i++)        &#123;            for (int j = v; j &gt;= b[i]; j--)            &#123;                for (int k = 1; k &lt;= p; k++)                &#123;                    c[k] = dp[j][k]; //体积为j时的第k大价值                    d[k] = dp[j - b[i]][k] + a[i];                &#125;                int q = 1, l = 1, r = 1;                while (q &lt;= p &amp;&amp; (l &lt;= p || r &lt;= p))                &#123;                    if (c[l] &gt;= d[r]) //比较两个数的大小，谁大就用谁赋值                    &#123;                        dp[j][q] = c[l++];                    &#125;                    else                    &#123;                        dp[j][q] = d[r++];                    &#125;                    if (dp[j][q] != dp[j][q - 1]) //这里要去一下重                    &#123;                        q++;                    &#125;                &#125;            &#125;        &#125;        printf(&quot;%d\\n&quot;, dp[v][p]);    &#125;    return 0;&#125;\n\n\n9 线段树&#x2F;搜索 · HDU 5323思路根据父子区间关系做 DFS，剪枝：右端点大于当前答案或左端点越界时返回。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans;void dfs(ll l, ll r) //建立左区间和右区间递归搜索&#123;    if (l == 0)    &#123;        if (r != 0)        &#123;            ans = min(ans, r);        &#125;    &#125;    if (r &gt;= ans) //右边界    &#123;        return;    &#125;    if (l - 1 - (r - l) &lt; 0) //左边界    &#123;        return;    &#125;    dfs(l - 1 - (r - l), r); //奇数区间    dfs(l, r + 1 + r - l);    dfs(l - 1 - (r - l) - 1, r); //偶数区间    dfs(l, r + 1 + r - l - 1);&#125;int main()&#123;    ll l, r;    while (scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r) != EOF)    &#123;        ans = 0x3f3f3f3f;        dfs(l, r);        if (l == 0 &amp;&amp; r == 0)        &#123;            printf(&quot;0\\n&quot;);        &#125;        else        &#123;            if (ans == 0x3f3f3f3f)            &#123;                printf(&quot;-1\\n&quot;);            &#125;            else            &#123;                printf(&quot;%lld\\n&quot;, ans);            &#125;        &#125;    &#125;    return 0;&#125;","categories":["算法"],"tags":["算法","动态规划","背包","线段树 ，搜索"]},{"title":"谷歌账号注册教程","url":"/posts/a3c9f8a9/","content":"准备工作\n稳定的科学上网环境  \n可接收验证码的手机号（国内 +86 亦可）\n\n注册步骤\n打开 Google 账号注册页面。\n依次填写姓名、用户名、密码并点击「下一步」。\n输入手机号 → 接收并填写验证码 → 继续。\n填写出生日期与性别 → 下一步。\n阅读隐私条款 → 点击「我同意」。\n完成后自动跳转至 Google 首页，即注册成功。\n\n常见问题\n收不到验证码？更换浏览器&#x2F;设备，或尝试语音电话验证。  \n提示“此号码已用过太多次”？更换号码，或等待 24 h 后再试。\n\n至此，谷歌账号注册完毕，可用于 Gmail、YouTube、Google Drive 等服务。\n","categories":["配置"],"tags":["配置","Google"]}]