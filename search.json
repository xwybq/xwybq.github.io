[{"title":"2022年上海市大学生程序设计竞赛","url":"/posts/99f768c5/","content":"N.Nine Is Greater Than Ten(签到）直接比较字典序。\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    string a, b;    cin &gt;&gt; a &gt;&gt; b;    if (a &gt; b)    &#123;        cout &lt;&lt; a &lt;&lt; &quot;&gt;&quot; &lt;&lt; b &lt;&lt; &quot;\\n&quot;;    &#125;    else if (a &lt; b)    &#123;        cout &lt;&lt; a &lt;&lt; &quot;&lt;&quot; &lt;&lt; b &lt;&lt; &quot;\\n&quot;;    &#125;    else    &#123;        cout &lt;&lt; a &lt;&lt; &quot;=&quot; &lt;&lt; b &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\nG.Gua!(签到)细节比较多的签到，主要是0的问题。若R &#x3D; 0，那么一枪都开不出，否则能开出 ⌊RxS&#x2F;60⌋ + 1枪。\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    &#123;        int b, r, d, s;        scanf(&quot;%d%d%d%d&quot;, &amp;b, &amp;r, &amp;d, &amp;s);        if (r == 0)        &#123;            if (d &gt; 0)            &#123;                printf(&quot;gua!\\n&quot;);            &#125;            else            &#123;                printf(&quot;ok\\n&quot;);            &#125;        &#125;        else if (s == 0)        &#123;            if (d &gt; b)            &#123;                printf(&quot;gua!\\n&quot;);            &#125;            else            &#123;                printf(&quot;ok\\n&quot;);            &#125;        &#125;        else        &#123;            int ans = s * r;            int cnt;            cnt = (ans / 60 + 1) * b;            if (d &gt; cnt)            &#123;                printf(&quot;gua!\\n&quot;);            &#125;            else            &#123;                printf(&quot;ok\\n&quot;);            &#125;        &#125;    &#125;    return 0;&#125;\n\nE.Expenditure Reduction（dp）题意：给一个字符串S，和S一个子序列F。求最短的S的子串T，使F也是T的子序列。\n思路：正解是dp（还可以枚举二分卡过去）\ndp[i][j]表示S到i，F匹配到第j位的最短长度。\n若s[i] !&#x3D; f[j]， 则dp[i][j] &#x3D; min(dp[i][j], dp[i - 1][j] + 1);\n若s[i] &#x3D;&#x3D; f[j]，则dp[i][j] &#x3D; min(dp[i][j], dp[i - 1][j - 1] + 1);\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int dp[N][108];const int INF = 0x3f3f3f3f;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int tt;    cin &gt;&gt; tt;    while (tt--)    &#123;        string s, f;        cin &gt;&gt; s &gt;&gt; f;        int n = s.size();        int m = f.size();        s = &#x27;#&#x27; + s;        f = &#x27;#&#x27; + f;        for (int i = 0; i &lt;= n; i++)        &#123;            for (int j = 1; j &lt;= m; j++)            &#123;                dp[i][j] = INF;            &#125;        &#125;        dp[0][0] = 0;        int pos = 0;        for (int i = 1; i &lt;= n; i++)        &#123;            for (int j = 1; j &lt;= m; j++)            &#123;                if (s[i] == f[j])                &#123;                    dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1);                &#125;                else                &#123;                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + 1);                &#125;            &#125;            if (dp[pos][m] &gt; dp[i][m])            &#123;                pos = i;            &#125;        &#125;        // cout &lt;&lt; pos &lt;&lt; &quot; &quot; &lt;&lt; dp[pos][m] &lt;&lt; &quot;\\n&quot;;        for (int i = pos - dp[pos][m] + 1; i &lt;= pos; i++)        &#123;            cout &lt;&lt; s[i];        &#125;        // cout &lt;&lt; s + pos - dp[pos][m] + 1;        cout &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\nH.Heirloom Painting（模拟，贪心）题意：用刷子刷长度为n的墙，每次用一种颜色刷连续的长度为k的一段，后刷的颜色会覆盖前刷的颜色。问给定结果，最小的刷墙次数。\n思路：容易想到，如果结果中根本没有长度不小于k的一段颜色相同，那么不可能刷出来，否则都可以刷出这个结果。\n我们发现只要有一段长度大于等于k，就一定能刷出来，所以直接从第一个连续段开始，从前往后刷就行了\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e6 + 10;int a[N];int b[N];signed main()&#123;    int t;    scanf(&quot;%lld&quot;, &amp;t);    while (t--)    &#123;        int n, m, k;        scanf(&quot;%lld%lld%lld&quot;, &amp;n, &amp;m, &amp;k);        for (int i = 1; i &lt;= n; i++)        &#123;            b[i] = 0;            scanf(&quot;%lld&quot;, &amp;a[i]);        &#125;        int cnt = 0;        a[0] = -1;        for (int i = 1; i &lt;= n; i++)        &#123;            if (a[i] != a[i - 1])            &#123;                b[++cnt] += 1;            &#125;            else            &#123;                b[cnt] += 1;            &#125;        &#125;        if (a[1] == a[n] &amp;&amp; cnt != 1) //看1和最后面的有无联系，如果相同就合并        &#123;            b[1] += b[cnt];            cnt -= 1;        &#125;        int flag = 0;        int sum = 0;        for (int i = 1; i &lt;= cnt; i++)        &#123;            if (b[i] &gt;= k)            &#123;                flag = 1;            &#125;            sum += ceil(b[i] * 1.0 / k);        &#125;        if (flag == 0)        &#123;            printf(&quot;-1\\n&quot;);        &#125;        else        &#123;            printf(&quot;%lld\\n&quot;, sum);        &#125;    &#125;    return 0;&#125;\n\nA.Another A+B Problem（搜索）思路：这题题意读着很难受，做不出来大概率是因为没读懂题QAQ\n本题主要难点就是搜索出满足约束的答案。容易发现，如果某个地方对应的是G，那么我们可以完全不管这个地方。然后我们查看每个数字对应的’P’,’B’个数。如果一个数字没有对应的’P’,’B’，意味着他在搜索时可以随便拿，没有数量限制。如果一个数字对应的全都是’P’（假设k个）,那么意味着它至少出现k次。如果一个数字既有’P’（k个）也有’B’，说明这个数字要刚好出现k次。同时，最后搜索结果要满足等式。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 11;char a[11], b[11];vector&lt;int&gt; v[11];int num[N];int vis[N];char c[N];const int INF = 0x3f3f3f3f;int cnt = 0;char ans[1000000 + 10][N];void dfs(int x)&#123;    if (x == 9)    &#123;        for (int i = 0; i &lt; 10; i++)        &#123;            if (num[i] &gt; 0 &amp;&amp; num[i] &lt; 1e4)            &#123;                return;            &#125;        &#125;        int z = (c[1] - &#x27;0&#x27;) * 10 + c[2] - &#x27;0&#x27;;        int x = (c[4] - &#x27;0&#x27;) * 10 + c[5] - &#x27;0&#x27;;        int m = (c[7] - &#x27;0&#x27;) * 10 + c[8] - &#x27;0&#x27;;        if (z + x != m)        &#123;            return;        &#125;        cnt += 1;        for (int i = 1; i &lt;= 8; i++)        &#123;            ans[cnt][i] = c[i];        &#125;        return;    &#125;    if (b[x] == &#x27;G&#x27;)    &#123;        dfs(x + 1);        return;    &#125;    for (int i = 0; i &lt; 10; i++)    &#123;        if (vis[i] == 0 &amp;&amp; num[i] == 0 || i == a[x] - &#x27;0&#x27;)        &#123;            continue;        &#125;        num[i] -= 1;        c[x] = i + &#x27;0&#x27;;        dfs(x + 1);        num[i] += 1;    &#125;&#125;int main()&#123;    cin &gt;&gt; a + 1 &gt;&gt; b + 1;    for (int i = 0; i &lt; 10; i++)    &#123;        num[i] = 1e5;        vis[i] = 1;    &#125;    for (int i = 1; i &lt;= 8; i++)    &#123;        if (b[i] == &#x27;G&#x27;)        &#123;            c[i] = a[i];            continue;        &#125;        v[a[i] - &#x27;0&#x27;].push_back(i);        // printf(&quot;%d %d\\n&quot;, a[i] - &#x27;0&#x27;, i);    &#125;    // for (int i = 0; i &lt; 10; i++)    // &#123;    //     printf(&quot;%d\\n&quot;, v[i]);    // &#125;    for (int i = 0; i &lt; 10; i++)    &#123;        if (v[i].size() == 0)        &#123;            continue;        &#125;        int sum = 0;        for (auto t : v[i])        &#123;            if (b[t] == &#x27;P&#x27;)            &#123;                sum++;            &#125;            else            &#123;                vis[i] = 0;            &#125;        &#125;        num[i] = sum;    &#125;    // for (int i = 0; i &lt; 10; i++)    // &#123;    //     printf(&quot;%d\\n&quot;, num[i]);    // &#125;    dfs(1);    cout &lt;&lt; cnt &lt;&lt; &quot;\\n&quot;;    for (int i = 1; i &lt;= cnt; i++)    &#123;        cout &lt;&lt; ans[i] + 1 &lt;&lt; &quot;\\n&quot;;    &#125;    return 0;&#125;\n\nM.My University Is Better Than Yours（tarjan缩点）题意：m个排行榜，只要有一个排行榜中a比b前，那么a就比b好。（a比b好和b比a好可以同时成立）且如果a比b好，b比c好，那么a比c好。求每所学校好于多少所学校。\n思路：每一个排行榜相邻两点建图的话是一条链状DAG，如果多个排行榜一起建图的话就会形成很多环，容易发现环上的点是共享答案的。因此可以缩成一个点。可以证明，缩完点之后的DAG也是链状的，因此可以直接求得。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;int n, m, b;vector&lt;int&gt; e[N];int dfn[N], low[N], tot;stack&lt;int&gt; s;int scc[N], siz[N], cnt;int din[N], dout[N];int a[N];int num[N];vector&lt;int&gt; v[N];void tarjan(int x)&#123;    dfn[x] = low[x] = ++tot;    s.push(x);    for (auto y : e[x])    &#123;        if (!dfn[y])        &#123;            tarjan(y);            low[x] = min(low[x], low[y]);        &#125;        else if (!scc[y])        &#123;            low[x] = min(low[x], dfn[y]);        &#125;    &#125;    if (dfn[x] == low[x])    &#123;        ++cnt;        while (1)        &#123;            int y = s.top();            s.pop();            scc[y] = cnt;            ++siz[cnt];            if (x == y)            &#123;                break;            &#125;        &#125;    &#125;&#125;void dfs(int x, int fa)&#123;    for (int t : v[x])    &#123;        if (t == fa)        &#123;            continue;        &#125;        dfs(t, x);        siz[x] += siz[t];    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int j = 1; j &lt;= m; j++)    &#123;        for (int i = 1; i &lt;= n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;a[i]);            if (i &gt; 1)            &#123;                e[a[i - 1]].push_back(a[i]);            &#125;        &#125;    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        if (!dfn[i])        &#123;            tarjan(i);        &#125;    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        for (auto t : e[i])        &#123;            if (scc[t] != scc[i])            &#123;                e[scc[i]].push_back(scc[t]);            &#125;        &#125;    &#125;    for (int i = 1; i &lt;= cnt; i++)    &#123;        siz[i] += siz[i - 1];    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        printf(&quot;%d &quot;, siz[scc[i]] - 1);    &#125;    printf(&quot;\\n&quot;);    return 0;&#125;\n\nL.Last Warning of the Competition Finance Officer（AC自动机+dp）思路：\n设dp[i]为1-i的得分, 划分中没有包含的子串）dp[i]&#x3D;dp[i−1](划分中没有包含i的子串）+∑j dp[i−len(tj)]∗val[tj] 我们可以发现，不同长度的t最多只有 ∑t 个，所以AC自动机压缩完路径后跳fail指针最多不超过 ∑t 个，直接AC自动机+转移即可。\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e5 + 5;int ch[N][26];int idx;int ne[N];char str[N], s[N];int e[N], g[N];const int mod = 998244353;int fuck[N];int dp[N];void insert(int x)&#123;    int p = 0;    int len = strlen(s + 1);    for (int i = 1; i &lt;= len; i++)    &#123;        int j = s[i] - &#x27;a&#x27;;        if (!ch[p][j])        &#123;            ch[p][j] = ++idx;        &#125;        p = ch[p][j];    &#125;    e[p] = x;    g[p] = len;&#125;void build()&#123;    queue&lt;int&gt; q;    for (int i = 0; i &lt; 26; i++)    &#123;        if (ch[0][i])        &#123;            q.push(ch[0][i]);        &#125;    &#125;    while (!q.empty())    &#123;        int u = q.front();        q.pop();        if (e[u])        &#123;            fuck[u] = u;        &#125;        else        &#123;            fuck[u] = fuck[ne[u]];        &#125;        for (int i = 0; i &lt; 26; i++)        &#123;            int v = ch[u][i];            if (v)            &#123;                ne[v] = ch[ne[u]][i];                q.push(v);            &#125;            else            &#123;                ch[u][i] = ch[ne[u]][i];            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%s&quot;, str + 1);    int m;    scanf(&quot;%d&quot;, &amp;m);    int ans;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%s%d&quot;, s + 1, &amp;ans);        insert(ans);    &#125;    build();    dp[0] = 1;    int n = strlen(str + 1);    for (int i = 1, u = 0; i &lt;= n; i++)    &#123;        dp[i] = dp[i - 1];        u = ch[u][str[i] - &#x27;a&#x27;];        for (int j = fuck[u]; j; j = fuck[ne[j]])        &#123;            if (g[j] &lt;= i)            &#123;                dp[i] += 1ll * dp[i - g[j]] * e[j] % mod;                dp[i] %= mod;            &#125;        &#125;        printf(&quot;%d &quot;, dp[i]);    &#125;    // printf(&quot;\\n&quot;);    return 0;&#125;\n\n","tags":["算法"]},{"title":"2023牛客寒假算法基础集训营3","url":"/posts/a82b503b/","content":"G：严肃古板的秩序\n思路：暴力搜索，暴力搜索三种符号的情况，看是否有一种能符合题意，如果有，就return 1，否则就是return 0；这个题写的时候有几个坑点要注意一下：\n1.定义a#b当且仅当a和b都是正整数时是有意义的。也就是说，在讨论#的时候，要先判断一下当前数和下一个数是否都大于0，才能递归下去\n2.a^a%b,用快速幂写时，不要忘了先把a初始化为a%b,不然就会WA\n代码：\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint a[100];int ans;char ch;int cnt = 0;char b[100];int ksm(int a, int b, int p)&#123;    int ans = 1;    a = a % p;    while (b)    &#123;        if (b &amp; 1)        &#123;            ans = ans * a % p;        &#125;        b &gt;&gt;= 1;        a = a * a % p;    &#125;    return ans % p;&#125;int dfs(int x, int pos)&#123;    if (pos == cnt)    &#123;        if (x == ans)        &#123;            for (int i = 1; i &lt;= cnt; i++)            &#123;                if (i == cnt)                &#123;                    cout &lt;&lt; a[cnt] &lt;&lt; &quot;=&quot; &lt;&lt; ans;                &#125;                else                &#123;                    cout &lt;&lt; a[i] &lt;&lt; b[i];                &#125;            &#125;            cout &lt;&lt; &#x27;\\n&#x27;;            return 1;        &#125;        return 0;    &#125;    b[pos] = &#x27;+&#x27;;    if (dfs(x + a[pos + 1], pos + 1) == 1)    &#123;        return 1;    &#125;    b[pos] = &#x27;-&#x27;;    if (dfs(x - a[pos + 1], pos + 1) == 1)    &#123;        return 1;    &#125;    b[pos] = &#x27;#&#x27;;    if (x &gt; 0 &amp;&amp; a[pos + 1] &gt; 0)    &#123;        if (dfs(ksm(x, x, a[pos + 1]), pos + 1) == 1)        &#123;            return 1;        &#125;    &#125;    return 0;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    while (1)    &#123;        ++cnt;        cin &gt;&gt; a[cnt];        cin &gt;&gt; ch;        if (ch == &#x27;=&#x27;)        &#123;            break;        &#125;    &#125;    cin &gt;&gt; ans;    if (dfs(a[1], 1) == 0)    &#123;        cout &lt;&lt; -1 &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n","tags":["算法】"]},{"title":"Hello World","url":"/posts/4a17b156/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"谷歌账号注册教程","url":"/posts/a3c9f8a9/","content":"准备工作\n稳定的科学上网环境  \n可接收验证码的手机号（国内 +86 亦可）\n\n注册步骤\n打开 Google 账号注册页面。\n依次填写姓名、用户名、密码并点击「下一步」。\n输入手机号 → 接收并填写验证码 → 继续。\n填写出生日期与性别 → 下一步。\n阅读隐私条款 → 点击「我同意」。\n完成后自动跳转至 Google 首页，即注册成功。\n\n常见问题\n收不到验证码？更换浏览器&#x2F;设备，或尝试语音电话验证。  \n提示“此号码已用过太多次”？更换号码，或等待 24 h 后再试。\n\n至此，谷歌账号注册完毕，可用于 Gmail、YouTube、Google Drive 等服务。\n","categories":["配置"],"tags":["配置","Google"]},{"title":"常用模板","url":"/posts/1590894c/","content":"[TOC]\n树状数组求逆序对[https://vjudge.net/contest/515986#problem/C]: \n#include &lt;bits/stdc++.h&gt;using namespace std;int n;const int N = 2e5 + 10;int a[N];int t[N];typedef long long ll;int lowbit(int x)&#123;    return x &amp; -x;&#125;void add(int x)&#123;    while (x &lt;= n)    &#123;        t[x]++;        x += lowbit(x);    &#125;&#125;int ask(int x)&#123;    int sum = 0;    while (x &gt;= 1)    &#123;        sum += t[x];        x -= lowbit(x);    &#125;    return sum;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    ll sum = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        add(a[i]);        sum += (i - ask(a[i]));    &#125;    printf(&quot;%lld\\n&quot;, sum);    return 0;&#125;\n\n树状数组求一个区间内有几种数#include &lt;bits/stdc++.h&gt;using namespace std;int n;const int N = 1e6 + 10;int tr[N];int num[N];int last[N];int ans[N];struct node&#123;    int l, r, pos;&#125; ask[N];bool cmp(node a, node b)&#123;    return a.r &lt; b.r;&#125;int lowbit(int x)&#123;    return x &amp; (-x);&#125;void add(int x, int ans)&#123;    while (x &lt;= n)    &#123;        tr[x] += ans;        x += lowbit(x);    &#125;&#125;int sum(int x)&#123;    int ans = 0;    while (x != 0)    &#123;        ans += tr[x];        x -= lowbit(x);    &#125;    return ans;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;num[i]);    &#125;    int m;    scanf(&quot;%d&quot;, &amp;m);    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;ask[i].l, &amp;ask[i].r);        ask[i].pos = i;    &#125;    sort(ask + 1, ask + 1 + m, cmp);    int fuck = 1;    for (int i = 1; i &lt;= m; i++)    &#123;        for (int j = fuck; j &lt;= ask[i].r; j++)        &#123;            if (last[num[j]])            &#123;                add(last[num[j]], -1);            &#125;            add(j, 1);            last[num[j]] = j;        &#125;        fuck = ask[i].r + 1;        ans[ask[i].pos] = sum(ask[i].r) - sum(ask[i].l - 1);    &#125;    for (int i = 1; i &lt;= m; i++)    &#123;        printf(&quot;%d\\n&quot;, ans[i]);    &#125;    return 0;&#125;\n\n二维前缀和#include &lt;bits/stdc++.h&gt;using namespace std;int sum[1001][1001];int main()&#123;    int m, n, x1, y1, x2, y2, value;    scanf(&quot;%d %d&quot;, &amp;n, &amp;m); //从一开始避免了分类讨论    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 1; j &lt;= m; j++)        &#123;            scanf(&quot;%d&quot;, &amp;value);            sum[i][j] = sum[i][j - 1] + sum[i - 1][j] - sum[i - 1][j - 1] + value;        &#125;    &#125;    int q;    scanf(&quot;%d&quot;, &amp;q);    while (q--)    &#123;        scanf(&quot;%d%d%d%d&quot;, &amp;x1, &amp;y1, &amp;x2, &amp;y2);        printf(&quot;%d\\n&quot;, sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1]);    &#125;    return 0;&#125;\n\n主席树查询一个区间有几个数#include&lt;bits/stdc++.h&gt;using namespace std;/* * 给出一个序列，查询区间内有多少个不相同的数 */const int MAXN = 30010;const int M = MAXN * 100;int n, q, tot;int a[MAXN];int T[M], lson[M], rson[M], c[M];int build(int l, int r)&#123;    int root = tot++;    c[root] = 0;    if (l != r)    &#123;        int mid = (l + r) &gt;&gt; 1;        lson[root] = build(l, mid);        rson[root] = build(mid + 1, r);    &#125;    return root;&#125;int update(int root, int pos, int val)&#123;    int newroot = tot++, tmp = newroot;    c[newroot] = c[root] + val;    int l = 1, r = n;    while (l &lt; r)    &#123;        int mid = (l + r) &gt;&gt; 1;        if (pos &lt;= mid)        &#123;            lson[newroot] = tot++;            rson[newroot] = rson[root];            newroot = lson[newroot];            root = lson[root];            r = mid;        &#125;        else        &#123;            rson[newroot] = tot++;            lson[newroot] = lson[root];            newroot = rson[newroot];            root = rson[root];            l = mid + 1;        &#125;        c[newroot] = c[root] + val;    &#125;    return tmp;&#125;int query(int root, int pos)&#123;    int ret = 0;    int l = 1, r = n;    while (pos &lt; r)    &#123;        int mid = (l + r) &gt;&gt; 1;        if (pos &lt;= mid)        &#123;            r = mid;            root = lson[root];        &#125;        else        &#123;            ret += c[lson[root]];            root = rson[root];            l = mid + 1;        &#125;    &#125;    return ret + c[root];&#125;int main()&#123;    // freopen(&quot;in.txt&quot;,&quot;r&quot;,stdin);    // freopen(&quot;out.txt&quot;,&quot;w&quot;,stdout);    while (scanf(&quot;%d&quot;, &amp;n) == 1)    &#123;        tot = 0;        for (int i = 1; i &lt;= n; i++)            scanf(&quot;%d&quot;, &amp;a[i]);        T[n + 1] = build(1, n); //建立一颗空树        map&lt;int, int&gt; mp;        for (int i = n; i &gt;= 1; i--)        &#123;            if (mp.find(a[i]) == mp.end())            &#123;                T[i] = update(T[i + 1], i, 1);            &#125;            else            &#123;                int tmp = update(T[i + 1], mp[a[i]], -1);                T[i] = update(tmp, i, 1);            &#125;            mp[a[i]] = i;        &#125;        scanf(&quot;%d&quot;, &amp;q);        while (q--)        &#123;            int l, r;            scanf(&quot;%d%d&quot;, &amp;l, &amp;r);            printf(&quot;%d\\n&quot;, query(T[l], r));        &#125;    &#125;    return 0;&#125;\n\n线段树求区间最大值减最小值#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;const int N = 5e4 + 10;int w[N];int n, q;int _max, _min;const int INF = 0x3f3f3f3f;struct node&#123;    int l, r, minn, maxn;&#125; tr[N * 4];void pushup(int u)&#123;    tr[u].minn = min(tr[u &lt;&lt; 1].minn, tr[u &lt;&lt; 1 | 1].minn);    tr[u].maxn = max(tr[u &lt;&lt; 1].maxn, tr[u &lt;&lt; 1 | 1].maxn);&#125;void build(int u, int l, int r)&#123;    tr[u].l = l;    tr[u].r = r;    if (l == r)    &#123;        tr[u].maxn = tr[u].minn = w[l];        return;    &#125;    int mid = l + r &gt;&gt; 1;    build(u &lt;&lt; 1, l, mid);    build(u &lt;&lt; 1 | 1, mid + 1, r);    pushup(u);&#125;void query(int u, int l, int r)&#123;    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)    &#123;        _max = max(_max, tr[u].maxn);        _min = min(_min, tr[u].minn);        return;    &#125;    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    if (l &lt;= mid)    &#123;        query(u &lt;&lt; 1, l, r);    &#125;    if (r &gt; mid)    &#123;        query(u &lt;&lt; 1 | 1, l, r);    &#125;&#125;int main()&#123;    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;w[i]);    &#125;    build(1, 1, n);    int l, r;    while (q--)    &#123;        scanf(&quot;%d%d&quot;, &amp;l, &amp;r);        _max = -INF;        _min = INF;        query(1, l, r);        printf(&quot;%d\\n&quot;, _max - _min);    &#125;    return 0;&#125;\n\n线段树区间修改和求和#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e5 + 10;int w[N];struct node&#123;    int l, r, sum, lazy;&#125; tr[N * 4];void pushup(int u)&#123;    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;&#125;void pushdown(int u)&#123;    if (tr[u].lazy != 0)    &#123;        tr[u &lt;&lt; 1].sum += (tr[u &lt;&lt; 1].r - tr[u &lt;&lt; 1].l + 1) * tr[u].lazy;        tr[u &lt;&lt; 1 | 1].sum += (tr[u &lt;&lt; 1 | 1].r - tr[u &lt;&lt; 1 | 1].l + 1) * tr[u].lazy;        tr[u &lt;&lt; 1].lazy += tr[u].lazy;        tr[u &lt;&lt; 1 | 1].lazy += tr[u].lazy;        tr[u].lazy = 0;    &#125;&#125;void build(int u, int l, int r)&#123;    tr[u] = &#123;l, r, w[l], 0&#125;;    if (l == r)    &#123;        return;    &#125;    int mid = (l + r) / 2;    build(u &lt;&lt; 1, l, mid);    build(u &lt;&lt; 1 | 1, mid + 1, r);    pushup(u);&#125;void update(int u, int l, int r, int k)&#123;    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)    &#123;        tr[u].sum += (tr[u].r - tr[u].l + 1) * k;        tr[u].lazy += k;        return;    &#125;    int mid = (tr[u].l + tr[u].r) / 2;    pushdown(u);    if (l &lt;= mid)    &#123;        update(u &lt;&lt; 1, l, r, k);    &#125;    if (r &gt; mid)    &#123;        update(u &lt;&lt; 1 | 1, l, r, k);    &#125;    pushup(u);&#125;int query(int u, int l, int r)&#123;    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)    &#123;        return tr[u].sum;    &#125;    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    pushdown(u);    int sum = 0;    if (l &lt;= mid)    &#123;        sum += query(u &lt;&lt; 1, l, r);    &#125;    if (r &gt; mid)    &#123;        sum += query(u &lt;&lt; 1 | 1, l, r);    &#125;    return sum;&#125;signed main()&#123;    int n, m;    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%lld&quot;, &amp;w[i]);    &#125;    build(1, 1, n);    int op;    int x, y, k;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%lld&quot;, &amp;op);        if (op == 1)        &#123;            scanf(&quot;%lld%lld%lld&quot;, &amp;x, &amp;y, &amp;k);            update(1, x, y, k);        &#125;        else        &#123;            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);            printf(&quot;%lld\\n&quot;, query(1, x, y));        &#125;    &#125;    return 0;&#125;\n\n线段树单点修改和区间求和#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 5e5 + 10;int w[N];struct node&#123;    int l, r, sum;&#125; tr[N * 4];void pushup(int u)&#123;    tr[u].sum = tr[u &lt;&lt; 1].sum + tr[u &lt;&lt; 1 | 1].sum;&#125;void build(int u, int l, int r)&#123;    tr[u] = &#123;l, r, w[l]&#125;;    if (l == r)    &#123;        return;    &#125;    int mid = l + r &gt;&gt; 1;    build(u &lt;&lt; 1, l, mid);    build(u &lt;&lt; 1 | 1, mid + 1, r);    pushup(u);&#125;void update(int u, int x, int k)&#123;    if (tr[u].l == x &amp;&amp; tr[u].r == x)    &#123;        tr[u].sum += k;        return;    &#125;    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    if (x &lt;= mid)    &#123;        update(u &lt;&lt; 1, x, k);    &#125;    else if (x &gt; mid)    &#123;        update(u &lt;&lt; 1 | 1, x, k);    &#125;    pushup(u);&#125;int query(int u, int l, int r)&#123;    if (tr[u].l &gt;= l &amp;&amp; tr[u].r &lt;= r)    &#123;        return tr[u].sum;    &#125;    int mid = tr[u].l + tr[u].r &gt;&gt; 1;    int sum = 0;    if (l &lt;= mid)    &#123;        sum += query(u &lt;&lt; 1, l, r);    &#125;    if (r &gt; mid)    &#123;        sum += query(u &lt;&lt; 1 | 1, l, r);    &#125;    return sum;&#125;signed main()&#123;    int n, m;    scanf(&quot;%lld%lld&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%lld&quot;, &amp;w[i]);    &#125;    build(1, 1, n);    int op;    int x, y, k;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%lld&quot;, &amp;op);        if (op == 1)        &#123;            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;k);            update(1, x, k);        &#125;        else        &#123;            scanf(&quot;%lld%lld&quot;, &amp;x, &amp;y);            printf(&quot;%lld\\n&quot;, query(1, x, y));        &#125;    &#125;    return 0;&#125;\n\nAC自动机求有多少个不同的模式串在文本串里出现过#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;int ne[N];int ch[N][26], cnt[N], idx;void insert(string s)&#123;    int p = 0;    for (int i = 0; s[i]; i++)    &#123;        int j = s[i] - &#x27;a&#x27;;        if (!ch[p][j])        &#123;            ch[p][j] = ++idx;        &#125;        p = ch[p][j];    &#125;    cnt[p]++;&#125;void build()&#123;    queue&lt;int&gt; q;    for (int i = 0; i &lt; 26; i++)    &#123;        if (ch[0][i])        &#123;            q.push(ch[0][i]);        &#125;    &#125;    while (!q.empty())    &#123;        int u = q.front();        q.pop();        for (int i = 0; i &lt; 26; i++)        &#123;            int v = ch[u][i];            if (v)            &#123;                ne[v] = ch[ne[u]][i];                q.push(v);            &#125;            else            &#123;                ch[u][i] = ch[ne[u]][i];            &#125;        &#125;    &#125;&#125;int query(string s)&#123;    int ans = 0;    for (int k = 0, i = 0; s[k]; k++)    &#123;        i = ch[i][s[k] - &#x27;a&#x27;];        for (int j = i; j &amp;&amp; ~cnt[j]; j = ne[j])        &#123;            ans += cnt[j];            cnt[j] = -1;        &#125;    &#125;    return ans;&#125;int main()&#123;    int t;    string a;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    &#123;        cin &gt;&gt; a;        insert(a);    &#125;    build();    cin &gt;&gt; a;    int ans = query(a);    printf(&quot;%d\\n&quot;, ans);    return 0;&#125;\n\n欧拉函数求小于n的互质数//试除法求单个欧拉函数#include&lt;bits/stdc++.h&gt;using namespace std;#define int long long int phi(int n)&#123;    int ans = n;    for (int i = 2; i * i &lt;= n; i++)    &#123;        if (n % i == 0)        &#123;            ans = ans * (i - 1) / i; //这里实际上是ans*(i分之i减一)            while (n % i == 0)            &#123;                n /= i;            &#125;        &#125;    &#125;    if (n &gt; 1)    &#123;        ans = ans * (n - 1) / n;    &#125;    return ans;&#125;signed main()&#123;    int n;    while (scanf(&quot;%lld&quot;, &amp;n) != EOF)    &#123;        if (n == 0)        &#123;            break;        &#125;        printf(&quot;%lld\\n&quot;, phi(n));    &#125;    return 0;&#125;//-------------------------------//筛法求1~n的欧拉函数#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;int p[N], vis[N], cnt;int phi[N];void get_phi(int n)&#123;    phi[1] = 1;    for (int i = 2; i &lt;= n; i++)    &#123;        if (!vis[i])        &#123;            p[cnt++] = i;            phi[i] = i - 1;        &#125;        for (int j = 0; i * p[j] &lt;= n; j++)        &#123;            int m = i * p[j];            vis[m] = 1;            if (i % p[j] == 0)            &#123;                phi[m] = p[j] * phi[i];                break;            &#125;            else            &#123;                phi[m] = (p[j] - 1) * phi[i];            &#125;        &#125;    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    get_phi(n);    for (int i = 1; i &lt;= n; i++)    &#123;        printf(&quot;%d\\n&quot;, phi[i]);    &#125;    return 0;&#125;\n\njava中的BigInteger类import java.lang.*;import java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        BigInteger a = sc.nextBigInteger();        BigInteger b = sc.nextBigInteger();        System.out.println(a.add(b));//相加        System.out.println(a.subtract(b));//相减        System.out.println(a.multiply(b));//相乘        System.out.println(a.divide(b));//相除取整        System.out.println(a.gcd(b));//最大公约数        System.out.println(a.abs());//绝对值        System.out.println(a.negate());//数字取反        int ans=10;        System.out.println(a.pow(ans));//幂次方        BigInteger mod=new BigInteger(&quot;1000000007&quot;);        System.out.println(a.remainder(mod));//取模        System.out.println(a.compareTo(b));//比较大小，大于返回1，小于返回-1，等于返回0        int x=2;        System.out.println(a.toString(x));//返回大整数x进制的字符串表示    &#125;&#125;\n\nLCA倍增写法//vector存储边#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;int dep[N];    // dep[u]存u点在树上的深度int fa[N][20]; // fa[u][i]存从u点向上跳2的i次方层的祖先结点vector&lt;int&gt; v[N];int n, m, s;void dfs(int u, int father)&#123;    dep[u] = dep[father] + 1;    fa[u][0] = father;    for (int i = 1; i &lt;= 19; i++) //跳2的0次方情况已经弄过了，所以从1开始    &#123;        fa[u][i] = fa[fa[u][i - 1]][i - 1]; //先向上跳2的i-1层，再向上跳2^i-1层    &#125;    for (auto t : v[u]) // dfs深搜就行    &#123;        if (t == father)            continue;        dfs(t, u);    &#125;&#125;int lca(int u, int v)&#123;    if (dep[u] &lt; dep[v]) //从深度大的开始跳    &#123;        swap(u, v);    &#125;    for (int i = 19; i &gt;= 0; i--) //先跳到同一层    &#123;        if (dep[fa[u][i]] &gt;= dep[v])        &#123;            u = fa[u][i];        &#125;    &#125;    if (u == v) //看看他俩在不在一条路径上    &#123;        return v;    &#125;    //否则就两个结点一起往上跳，找到第一个相同的结点    for (int i = 19; i &gt;= 0; i--)    &#123;        if (fa[u][i] != fa[v][i])        &#123;            u = fa[u][i], v = fa[v][i];        &#125;    &#125;    //跳到最后一定是再跳1层就行，但判断之后不符合条件就直接退出了，所以最后u和v并没有赋值，得到的实际上是最近公共祖先的子节点    return fa[u][0]; //返回再跳一层的值即可&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);    int x, y;    for (int i = 1; i &lt;= n - 1; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        v[x].push_back(y);        v[y].push_back(x);    &#125;    dfs(s, 0);    int u, v;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        printf(&quot;%d\\n&quot;, lca(u, v));    &#125;    return 0;&#125;//-----------------------------------------//链式前向星存储边#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;struct node&#123;    int to, nex;&#125; a[N * 2];int dep[N];    // dep[u]存u点在树上的深度int fa[N][20]; // fa[u][i]存从u点向上跳2的i次方层的祖先结点// vector&lt;int&gt; v[N];int n, m, s;int head[N];int idx;void add(int u, int v)&#123;    a[++idx].to = v;    a[idx].nex = head[u];    head[u] = idx;&#125;void dfs(int u, int father)&#123;    dep[u] = dep[father] + 1;    fa[u][0] = father;    for (int i = 1; i &lt;= 19; i++) //跳2的0次方情况已经弄过了，所以从1开始    &#123;        fa[u][i] = fa[fa[u][i - 1]][i - 1]; //先向上跳2的i-1层，再向上跳2^i-1层    &#125;    for (int i = head[u]; i != -1; i = a[i].nex)    &#123;        if (a[i].to == father)        &#123;            continue;        &#125;        dfs(a[i].to, u);    &#125;&#125;int lca(int u, int v)&#123;    if (dep[u] &lt; dep[v]) //从深度大的开始跳    &#123;        swap(u, v);    &#125;    for (int i = 19; i &gt;= 0; i--) //先跳到同一层    &#123;        if (dep[fa[u][i]] &gt;= dep[v])        &#123;            u = fa[u][i];        &#125;    &#125;    if (u == v) //看看他俩在不在一条路径上    &#123;        return v;    &#125;    //否则就两个结点一起往上跳，找到第一个相同的结点    for (int i = 19; i &gt;= 0; i--)    &#123;        if (fa[u][i] != fa[v][i])        &#123;            u = fa[u][i], v = fa[v][i];        &#125;    &#125;    //跳到最后一定是再跳1层就行，但判断之后不符合条件就直接退出了，所以最后u和v并没有赋值，得到的实际上是最近公共祖先的子节点    return fa[u][0]; //返回再跳一层的值即可&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);    memset(head, -1, sizeof(head));    int x, y;    for (int i = 1; i &lt;= n - 1; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);        add(x, y);        add(y, x);    &#125;    dfs(s, 0);    int u, v;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;u, &amp;v);        printf(&quot;%d\\n&quot;, lca(u, v));    &#125;    return 0;&#125;\n\nLCATraJan写法#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e5 + 10;int n, m, s, a, b;vector&lt;int&gt; e[N];vector&lt;pair&lt;int, int&gt;&gt; query[N];int fa[N], vis[N], ans[N];int find(int x)&#123;    if (x == fa[x])    &#123;        return x;    &#125;    else    &#123;        return fa[x] = find(fa[x]);    &#125;&#125;void tarjan(int x)&#123;    vis[x] = 1; //标记x已访问    for (auto t : e[x])    &#123;        if (vis[t] == 0)        &#123;            tarjan(t);            fa[t] = x; //回到x时指向x        &#125;    &#125;    //离开x时找LCA    for (auto q : query[x])    &#123;        int y = q.first, i = q.second;        if (vis[y] == 1)        &#123;            ans[i] = find(y);        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;s);    for (int i = 1; i &lt;= n - 1; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        e[a].push_back(b);        e[b].push_back(a);    &#125;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;a, &amp;b);        query[a].push_back(&#123;b, i&#125;);        query[b].push_back(&#123;a, i&#125;);    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        fa[i] = i;    &#125;    tarjan(s);    for (int i = 1; i &lt;= m; i++)    &#123;        printf(&quot;%d\\n&quot;, ans[i]);    &#125;    return 0;&#125;\n\n拓扑排序（Kahn算法)//https://vjudge.net/problem/UVA-10305#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e2 + 10;int n, m;int din[N];vector&lt;int&gt; e[N], ans;void toposort()&#123;    queue&lt;int&gt; q;    for (int i = 1; i &lt;= n; i++)    &#123;        if (din[i] == 0)        &#123;            q.push(i);        &#125;    &#125;    while (!q.empty())    &#123;        int x = q.front();        q.pop();        ans.push_back(x);        for (auto y : e[x])        &#123;            --din[y];            if (din[y] == 0)            &#123;                q.push(y);            &#125;        &#125;    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    while (1)    &#123;        cin &gt;&gt; n &gt;&gt; m;        if (n == 0 &amp;&amp; m == 0)        &#123;            break;        &#125;        for (int i = 1; i &lt;= N; i++)        &#123;            e[i].clear();        &#125;        memset(din, 0, sizeof(din));        ans.clear();        int a, b;        for (int i = 1; i &lt;= m; i++)        &#123;            cin &gt;&gt; a &gt;&gt; b;            e[a].push_back(b);            din[b]++;        &#125;        toposort();        for (auto x : ans)        &#123;            cout &lt;&lt; x &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n字典树求最大异或对#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int n, a[N];int ch[N * 31][2];//ch[p][j]表示p号结点沿着j这条边到达的子节点int idx;void insert(int x)&#123;    int p = 0;    for (int i = 30; i &gt;= 0; i--)    &#123;        int j = x &gt;&gt; i &amp; 1;        if (!ch[p][j])        &#123;            ch[p][j] = ++idx;        &#125;        p = ch[p][j];        // printf(&quot;%d\\n&quot;, idx);    &#125;&#125;int query(int x)&#123;    int p = 0, sum = 0;    for (int i = 30; i &gt;= 0; i--)    &#123;        int j = x &gt;&gt; i &amp; 1;        if (ch[p][!j])        &#123;            sum += 1 &lt;&lt; i;            p = ch[p][!j];        &#125;        else        &#123;            p = ch[p][j];        &#125;    &#125;    return sum;&#125;int main()&#123;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        insert(a[i]);    &#125;    int maxn = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        maxn = max(maxn, query(a[i]));    &#125;    printf(&quot;%d\\n&quot;, maxn);    return 0;&#125;\n\n优先队列 priority_queueempty() 如果队列为空返回真\npop() 删除对顶元素\npush() 加入一个元素\nsize() 返回优先队列中拥有的元素个数\ntop() 返回优先队列队顶元素\n在默认的优先队列中，优先级高的先出队。在默认的 int 型中先出队的为较大的数\n1 priority_queue&lt;int&gt;q1;//大的先出对2 priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt;q2; //小的先出队\n\n自定义比较函数：\n1 struct cmp2 &#123;3 bool operator ()(int x, int y)4 &#123;5 return x &gt; y; // x 小的优先级高6 //也可以写成其他方式，如：return p[x] &gt; p[y]; 表示 p[i] 小的优先级高7 &#125;8 &#125;;9 priority_queue&lt;int, vector&lt;int&gt;, cmp&gt;q;//定义方法10 //其中，第二个参数为容器类型。第三个参数为比较函数。\n\nstruct node2 &#123;3 int x, y;4 friend bool operator &lt; (node a, node b)5 &#123;6 return a.x &gt; b.x; //结构体中，x 小的优先级高7 &#125;8 &#125;;9 priority_queue&lt;node&gt;q;//定义方法10 //在该结构中，y 为值, x 为优先级。11 //通过自定义 operator&lt; 操作符来比较元素中的优先级。12 //在重载”&lt;”时，最好不要重载”&gt;”，可能会发生编译错误\n\n求逆元的四种方法\n扩展欧几里得求逆元\n\n这种方法常数最小\ntypedef  long long ll;void extgcd(ll a,ll b,ll&amp; d,ll&amp; x,ll&amp; y)&#123;    if(!b)&#123; d=a; x=1; y=0;&#125;    else&#123; extgcd(b,a%b,d,y,x); y-=x*(a/b); &#125;&#125;ll inverse(ll a,ll n)&#123;    ll d,x,y;    extgcd(a,n,d,x,y);    return d==1?(x+n)%n:-1;&#125;\n\n\n费马小定理求逆元（%m为素数）\n\n如果一个数m为素数，那么a^(m-1)≡1 (mod m)，那么a的逆元就是a^(m-2)，这是根据费马小定理推出来的。\ntypedef  long long ll;ll pow_mod(ll x, ll n, ll mod)&#123;    ll res=1;    while(n&gt;0)&#123;        if(n&amp;1)res=res*x%mod;        x=x*x%mod;        n&gt;&gt;=1;    &#125;    return res;&#125;ll ans = pow_mod(a,m-2,m);\n\n\n欧拉函数求逆元（%p不为素数）：\n\nlong long eular(long long n)&#123;    long long ans = n;    for(int i = 2; i*i &lt;= n; i++)    &#123;        if(n % i == 0)        &#123;            ans -= ans/i; //等价于通项，把n乘进去            while(n % i == 0) //确保下一个i是n的素因数                n /= i;        &#125;    &#125;    if(n &gt; 1)ans -= ans/n; //最后可能还剩下一个素因数没有除    return ans;&#125;\n\n注意，求出φ(n)以后依旧是mod n。\n然后根据a^(φ(n))≡1 (mod n)，再拉个快速幂就行了。\n\n逆元打表​      最喜欢的就是这个了\ntypedef  long long ll;const int N = 1e5 + 5;int inv[N]; void inverse(int n, int p) &#123;    inv[1] = 1;    for (int i=2; i&lt;=n; ++i) &#123;        inv[i] = (ll) (p - p / i) * inv[p%i] % p;    &#125;&#125;\n\nn!的逆元// 先利用费马小定理求出 n! 的逆元，再倒推求(n-1)!... 的逆元inv[N] = power(fac[N], MOD - 2); // fac[n]为 N 的阶乘for (i = N - 1; i &gt;= 0; i--)    inv[i] = 1ll * inv[i + 1] * (i + 1) % MOD;\n\n容斥原理（并集）#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 20;int n, m, prim[N];/*给定一个整数n和m个不同的质数p1,p2,...,pm ,求1～n中能被p1,p2,…,pm中的至少一个数整除的数有多少个?其中m≤16, n, pi ≤ 10*/// 2 3// 2 3 5// 10int calc()&#123;    int res = 0;    for (int i = 1; i &lt; 1 &lt;&lt; m; i++)    &#123;        int t = 1, sign = -1;        for (int j = 0; j &lt; m; j++)        &#123;            if (i &amp; 1 &lt;&lt; j)            &#123;                if (t * prim[j] &gt; n)                &#123;                    t = 0;                    break;                &#125;                t *= prim[j];                sign = -sign;            &#125;        &#125;        if (t)        &#123;            res += n / t * sign;        &#125;    &#125;    return res;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m;    for (int i = 0; i &lt; m; i++)    &#123;        cin &gt;&gt; prim[i];    &#125;    cout &lt;&lt; calc() &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n容斥原理（交集）// 洛谷P1450，它的本质是全集减补集的并集#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e5 + 10;int c[10], d[10];int dp[N];int n;int s;void init()&#123;    dp[0] = 1;    for (int i = 1; i &lt;= 4; i++)    &#123;        for (int j = c[i]; j &lt;= N; j++)        &#123;            dp[j] += dp[j - c[i]];        &#125;    &#125;&#125;int calc()&#123;    int ans = 0;    for (int i = 1; i &lt; 1 &lt;&lt; 4; i++)    &#123;        int t = 0, sign = -1;        for (int j = 1; j &lt;= 4; j++)        &#123;            if (i &amp; 1 &lt;&lt; (j - 1))            &#123;                t += c[j] * (d[j] + 1);                sign = -sign;            &#125;        &#125;        if (s &gt;= t)        &#123;            ans += dp[s - t] * sign;        &#125;    &#125;    return dp[s] - ans;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    for (int i = 1; i &lt;= 4; i++)    &#123;        cin &gt;&gt; c[i];    &#125;    init();    cin &gt;&gt; n;    while (n--)    &#123;        for (int i = 1; i &lt;= 4; i++)        &#123;            cin &gt;&gt; d[i];        &#125;        cin &gt;&gt; s;        cout &lt;&lt; calc() &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n筛法求莫比乌斯函数\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e6 + 10;int p[N], vis[N], cnt;int mu[N];void get_mu(int n)&#123;    mu[1] = 1;    for (int i = 2; i &lt;= n; i++)    &#123;        if (!vis[i])        &#123;            p[++cnt] = i;            mu[i] = -1;        &#125;        for (int j = 1; i * p[j] &lt;= n; j++)        &#123;            int m = i * p[j];            vis[m] = 1;            if (i % p[j] == 0)            &#123;                mu[m] = 0;                break;            &#125;            else            &#123;                mu[m] = -mu[i];            &#125;        &#125;    &#125;&#125;signed main()&#123;    int n;    cin &gt;&gt; n;    get_mu(n);    for (int i = 1; i &lt;= n; i++)    &#123;        cout &lt;&lt; mu[i] &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\nBSGS算法\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint bsgs(int a, int b, int p)&#123;    a %= p, b %= p;    if (b == 1)    &#123;        return 0;    &#125;    int m = ceil(sqrt(p));    int t = b;    unordered_map&lt;int, int&gt; hash;    hash[b] = 0;    for (int j = 1; j &lt; m; j++)    &#123;        t = t * a % p;        hash[t] = j;    &#125;    int mi = 1;    for (int i = 1; i &lt;= m; i++)    &#123;        mi = mi * a % p;    &#125;    t = 1;    for (int i = 1; i &lt;= m; i++)    &#123;        t = t * mi % p;        if (hash.count(t))        &#123;            return i * m - hash[t];        &#125;    &#125;    return -1;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int p, b, n;    cin &gt;&gt; p &gt;&gt; b &gt;&gt; n;    int ans = bsgs(b, n, p);    if (ans == -1)    &#123;        cout &lt;&lt; &quot;no solution&quot; &lt;&lt; &#x27;\\n&#x27;;    &#125;    else    &#123;        cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n扩展BSGS算法\n// 洛谷 4195// 用于a和p不互质的情况#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long LL;LL gcd(LL a, LL b)&#123;    return b == 0 ? a : gcd(b, a % b);&#125;LL exbsgs(LL a, LL b, LL p)&#123;    a %= p;    b %= p;    if (b == 1 || p == 1)        return 0; // x=0    LL d, k = 0, A = 1;    while (true)    &#123;        d = gcd(a, p);        if (d == 1)            break;        if (b % d)            return -1; // 无解        k++;        b /= d;        p /= d;        A = A * (a / d) % p; // 求a^k/D        if (A == b)            return k;    &#125;    LL m = ceil(sqrt(p));    LL t = b;    unordered_map&lt;int, int&gt; hash;    hash[b] = 0;    for (int j = 1; j &lt; m; j++)    &#123;        t = t * a % p; // 求b*a^j        hash[t] = j;    &#125;    LL mi = 1;    for (int i = 1; i &lt;= m; i++)        mi = mi * a % p; // 求a^m    t = A;    for (int i = 1; i &lt;= m; i++)    &#123;        t = t * mi % p; // 求(a^m)^i        if (hash.count(t))            return i * m - hash[t] + k;    &#125;    return -1; // 无解&#125;int main()&#123;    LL a, p, b;    while ((scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;p, &amp;b) != EOF) &amp;&amp; a)    &#123;        LL res = exbsgs(a, b, p);        if (res == -1)            puts(&quot;No Solution&quot;);        else            printf(&quot;%lld\\n&quot;, res);    &#125;    return 0;&#125;\n\n威尔逊定理\n//HDU 2973#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1000001;const int mx = 3000008;int s[N], p[N], vis[mx], t, n;void get_prim()&#123;    for (long long i = 2; i &lt; mx; ++i)    &#123;        if (!vis[i])        &#123;            if ((i - 7) % 3 == 0)            &#123;                p[(i - 7) / 3] = 1;            &#125;            for (long long j = i * i; j &lt; mx; j += i)            &#123;                vis[j] = 1;            &#125;        &#125;    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    get_prim();    for (int i = 2; i &lt; N; ++i)    &#123;        s[i] = s[i - 1] + p[i];    &#125;    cin &gt;&gt; t;    while (t--)    &#123;        cin &gt;&gt; n;        cout &lt;&lt; s[n] &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n裴蜀定理\n// luogu 4549#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longsigned main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    int n;    cin &gt;&gt; n;    vector&lt;int&gt; a(n + 1);    for (int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; a[i];    &#125;    int s = a[1];    for (int i = 1; i &lt;= n; i++)    &#123;        s = __gcd(abs(a[i]), s);    &#125;    cout &lt;&lt; s &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n卡特兰数(Catalan数)\n\n//luogu P1044#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint f[200];signed main()&#123;    ios::sync_with_stdio(false); // 关闭同步流，提升cin、cout读入输出效率    cin.tie(0);                  // 解除 cin 与 cout 的绑定，提升输入速度    cout.tie(0);    int n;    cin &gt;&gt; n;    f[0] = 1;    for (int i = 1; i &lt;= n; i++)    &#123;        f[i] = f[i - 1] * (i * 4 - 2) / (i + 1);    &#125;    cout &lt;&lt; f[n] &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n普通生成函数\n//HDU 2152#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint n, m;const int N = 1e2 + 10;int a[N], b[N], c[N], d[N];int clac()&#123;    for (int i = 0; i &lt;= m; i++)    &#123;        c[i] = d[i] = 0;    &#125;    for (int i = a[1]; i &lt;= b[1]; i++)    &#123;        c[i] = 1;    &#125;    for (int i = 2; i &lt;= n; i++)    &#123;        for (int j = 0; j &lt;= m; j++)        &#123;            for (int k = a[i]; k &lt;= b[i]; k++)            &#123;                d[j + k] += c[j];            &#125;        &#125;        for (int j = 0; j &lt;= m; j++)        &#123;            c[j] = d[j];            d[j] = 0;        &#125;    &#125;    return c[m];&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    while (cin &gt;&gt; n &gt;&gt; m)    &#123;        for (int i = 1; i &lt;= n; i++)        &#123;            cin &gt;&gt; a[i] &gt;&gt; b[i];        &#125;        cout &lt;&lt; clac() &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n// HDU 1085#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e5 + 10;int a[N], b[N], c[N], d[N];void clac(int m)&#123;    for (int i = 0; i &lt;= m; i++)    &#123;        c[i] = d[i] = 0;    &#125;    for (int i = 0; i &lt;= a[1]; i++)    &#123;        c[i] = 1;    &#125;    for (int i = 2; i &lt;= 3; i++)    &#123;        for (int j = 0; j &lt;= m; j++)        &#123;            for (int k = 0; k &lt;= b[i] * a[i] &amp;&amp; (j + k) &lt;= m; k += b[i])            &#123;                d[j + k] += c[j];            &#125;        &#125;        for (int j = 0; j &lt;= m; j++)        &#123;            c[j] = d[j];            d[j] = 0;        &#125;    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    while (1)    &#123;        cin &gt;&gt; a[1] &gt;&gt; a[2] &gt;&gt; a[3];        if (a[1] == 0 &amp;&amp; a[2] == 0 &amp;&amp; a[3] == 0)        &#123;            break;        &#125;        b[1] = 1, b[2] = 2, b[3] = 5;        int m = a[1] * 1 + a[2] * 2 + a[3] * 5;        clac(m);        int x = 1;        while (x &lt;= m &amp;&amp; c[x])        &#123;            x++;        &#125;        cout &lt;&lt; x &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n指数生成函数\n// HDU 1521#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e2 + 10;int n, m;int a[N];double c[N], d[N];double fac[N];void init()&#123;    fac[0] = fac[1] = 1;    for (int i = 2; i &lt;= 10; i++)    &#123;        fac[i] = fac[i - 1] * i;    &#125;&#125;double calc()&#123;    for (int i = 0; i &lt;= m; i++)    &#123;        c[i] = d[i] = 0;    &#125;    for (int i = 0; i &lt;= a[1]; i++)    &#123;        c[i] = 1.0 / fac[i];    &#125;    for (int i = 2; i &lt;= n; i++)    &#123;        for (int j = 0; j &lt;= m; j++)        &#123;            for (int k = 0; k &lt;= a[i]; k++)            &#123;                d[j + k] += c[j] / fac[k];            &#125;        &#125;        for (int j = 0; j &lt;= m; j++)        &#123;            c[j] = d[j];            d[j] = 0;        &#125;    &#125;    return c[m] * fac[m];&#125;signed main()&#123;    // ios::sync_with_stdio(false);    // cin.tie(0);    // cout.tie(0);    init();    while (cin &gt;&gt; n &gt;&gt; m)    &#123;        for (int i = 1; i &lt;= n; i++)        &#123;            cin &gt;&gt; a[i];        &#125;        printf(&quot;%.0lf\\n&quot;, calc());    &#125;    return 0;&#125;\n\n生成函数的应用\n\n// https://darkbzoj.cc/problem/3028#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 10007;int qpow(int a, int b)&#123;    int ans = 1;    while (b)    &#123;        if (b &amp; 1)        &#123;            ans = ans * a % mod;        &#125;        a = a * a % mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    string a;    cin &gt;&gt; a;    int n = 0;    for (int i = 0; i &lt; a.size(); i++)    &#123;        n = (n * 10 % mod + a[i] - &#x27;0&#x27;) % mod;    &#125;    cout &lt;&lt; n * (n + 1) % mod * (n + 2) % mod * qpow(6, mod - 2) % mod &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n// POJ 3734#include &lt;iostream&gt;using namespace std;#define int long longconst int mod = 10007;int ksm(int a, int b)&#123;    int ans = 1;    while (b)    &#123;        if (b &amp; 1)        &#123;            ans = ans * a % mod;        &#125;        a = a * a % mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;signed main()&#123;    int t;    cin &gt;&gt; t;    while (t--)    &#123;        int n;        cin &gt;&gt; n;        cout &lt;&lt; (ksm(4, n - 1) + ksm(2, n - 1)) % mod &lt;&lt; &#x27;\\n&#x27;;    &#125;&#125;\n\n狄利克雷卷积\n和式的变换\n\n// luogu 3455#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 5e4 + 10;int mu[N];int p[N], vis[N];int cnt;void get_mu(int n)&#123;    mu[1] = 1;    for (int i = 2; i &lt;= n; i++)    &#123;        if (!vis[i])        &#123;            p[++cnt] = i;            mu[i] = -1;        &#125;        for (int j = 1; i * p[j] &lt;= n; j++)        &#123;            int m = i * p[j];            vis[m] = 1;            if (i % p[j] == 0)            &#123;                mu[m] = 0;                break;            &#125;            else            &#123;                mu[m] = -mu[i];            &#125;        &#125;    &#125;&#125;void init()&#123;    get_mu(N);    for (int i = 1; i &lt;= N; i++)    &#123;        mu[i] += mu[i - 1];    &#125;&#125;int cal(int n, int m, int k)&#123;    if (n &gt; m)    &#123;        swap(n, m);    &#125;    n /= k, m /= k;    int ans = 0;    for (int l = 1, r; l &lt;= n; l = r + 1)    &#123;        r = min(n / (n / l), m / (m / l));        ans += (mu[r] - mu[l - 1]) * (n / l) * (m / l);    &#125;    return ans;&#125;signed main()&#123;    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    init();    int n;    cin &gt;&gt; n;    int a, b, d;    for (int i = 1; i &lt;= n; i++)    &#123;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; d;        cout &lt;&lt; cal(a, b, d) &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n\n\n// luogu 2257#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e7 + 10;int mu[N];int p[N], vis[N];int cnt;int F[N];void init()&#123;    mu[1] = 1;    for (int i = 2; i &lt; N; i++)    &#123;        if (!vis[i])        &#123;            p[++cnt] = i;            mu[i] = -1;        &#125;        for (int j = 1; i * p[j] &lt; N; j++)        &#123;            int m = i * p[j];            vis[m] = 1;            if (i % p[j] == 0)            &#123;                mu[m] = 0;                break;            &#125;            else            &#123;                mu[m] = -mu[i];            &#125;        &#125;    &#125;    for (int i = 1; i &lt;= cnt; i++)    &#123;        for (int j = p[i]; j &lt; N; j += p[i])        &#123;            F[j] += mu[j / p[i]];        &#125;    &#125;    for (int i = 1; i &lt; N; i++)    &#123;        F[i] += F[i - 1];    &#125;&#125;int cal(int n, int m)&#123;    if (n &gt; m)    &#123;        swap(n, m);    &#125;    int ans = 0;    for (int l = 1, r; l &lt;= n; l = r + 1)    &#123;        r = min(n / (n / l), m / (m / l));        ans += (F[r] - F[l - 1]) * (n / l) * (m / l);    &#125;    return ans;&#125;signed main()&#123;    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    init();    int t;    cin &gt;&gt; t;    int a, b;    while (t--)    &#123;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; cal(a, b) &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n\n\n// luogu 3327#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 5e4 + 10;int mu[N];int p[N], vis[N];int cnt;int F[N];void init()&#123;    mu[1] = 1;    for (int i = 2; i &lt; N; i++)    &#123;        if (!vis[i])        &#123;            p[++cnt] = i;            mu[i] = -1;        &#125;        for (int j = 1; i * p[j] &lt; N; j++)        &#123;            int m = i * p[j];            vis[m] = 1;            if (i % p[j] == 0)            &#123;                mu[m] = 0;                break;            &#125;            else            &#123;                mu[m] = -mu[i];            &#125;        &#125;    &#125;    for (int i = 1; i &lt; N; i++)    &#123;        mu[i] += mu[i - 1];    &#125;    for (int i = 1; i &lt; N; i++)    &#123;        for (int l = 1, r; l &lt;= i; l = r + 1)        &#123;            r = i / (i / l);            F[i] += (r - l + 1) * (i / l);        &#125;    &#125;&#125;int cal(int n, int m)&#123;    if (n &gt; m)    &#123;        swap(n, m);    &#125;    int ans = 0;    for (int l = 1, r; l &lt;= n; l = r + 1)    &#123;        r = min(n / (n / l), m / (m / l));        ans += (mu[r] - mu[l - 1]) * F[n / l] * F[m / l];    &#125;    return ans;&#125;signed main()&#123;    ios::sync_with_stdio(0);    cin.tie(0);    cout.tie(0);    init();    int t;    cin &gt;&gt; t;    int a, b;    while (t--)    &#123;        cin &gt;&gt; a &gt;&gt; b;        cout &lt;&lt; cal(a, b) &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n莫比乌斯反演\n\n// luogu 1829#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int N = 1e7 + 10;const int mod = 20101009;int vis[N], p[N], mu[N], S[N], cnt;void init()&#123;    mu[1] = 1;    for (int i = 2; i &lt; N; i++)    &#123;        if (!vis[i])        &#123;            p[++cnt] = i;            mu[i] = -1;        &#125;        for (int j = 1; i * p[j] &lt; N; j++)        &#123;            vis[i * p[j]] = 1;            if (i % p[j] == 0)            &#123;                break;            &#125;            mu[i * p[j]] = -mu[i];        &#125;    &#125;    for (int i = 1; i &lt; N; i++)    &#123;        S[i] = (S[i - 1] + mu[i] * i * i % mod + mod) % mod;    &#125;&#125;int G(int n, int m)&#123;    return (n * (n + 1) / 2 % mod) * (m * (m + 1) / 2 % mod) % mod;&#125;int F(int n, int m)&#123;    int ans = 0;    for (int l = 1, r; l &lt;= n; l = r + 1)    &#123;        r = min(n / (n / l), m / (m / l));        ans = (ans + (S[r] - S[l - 1]) * G(n / l, m / l) % mod + mod) % mod;    &#125;    return ans;&#125;int cal(int n, int m)&#123;    if (n &gt; m)    &#123;        swap(n, m);    &#125;    int ans = 0;    for (int l = 1, r; l &lt;= n; l = r + 1)    &#123;        r = min(n / (n / l), m / (m / l));        ans = (ans + (r - l + 1) * (l + r) / 2 % mod * F(n / l, m / l) % mod) % mod;    &#125;    return ans;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    init();    int n, m;    cin &gt;&gt; n &gt;&gt; m;    cout &lt;&lt; cal(n, m) &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n\n\n// https://www.luogu.com.cn/problem/P3704#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longint n, m;const int mod = 1e9 + 7;const int N = 1e6 + 10;int prime[N], vis[N], mu[N];int f[N], F[N];int g[N];int cnt;int ksm(int a, int b)&#123;    int ans = 1;    while (b)    &#123;        if (b &amp; 1)        &#123;            ans = ans * a % mod;        &#125;        a = a * a % mod;        b &gt;&gt;= 1;    &#125;    return ans;&#125;void init()&#123;    mu[1] = 1;    for (int i = 2; i &lt; N; i++)    &#123;        if (!vis[i])        &#123;            prime[++cnt] = i;            mu[i] = -1;        &#125;        for (int j = 1; i * prime[j] &lt; N; j++)        &#123;            vis[i * prime[j]] = 1;            if (i % prime[j] == 0)            &#123;                break;            &#125;            mu[i * prime[j]] = -mu[i];        &#125;    &#125;    f[1] = g[1] = 1;    F[0] = F[1] = 1;    for (int i = 2; i &lt; N; i++)    &#123;        f[i] = (f[i - 1] + f[i - 2]) % mod;        g[i] = ksm(f[i], mod - 2);        F[i] = 1;    &#125;    for (int i = 1; i &lt; N; i++)    &#123;        for (int j = i; j &lt; N; j += i)        &#123;            if (mu[j / i])            &#123;                F[j] = F[j] * (mu[j / i] == 1 ? f[i] : g[i]) % mod;            &#125;        &#125;    &#125;    for (int i = 2; i &lt; N; i++)    &#123;        F[i] = F[i - 1] * F[i] % mod;    &#125;&#125;int calc(int n, int m)&#123;    if (n &gt; m)    &#123;        swap(n, m);    &#125;    int ans = 1;    for (int l = 1, r; l &lt;= n; l = r + 1)    &#123;        r = min(n / (n / l), m / (m / l));        int s = F[r] * ksm(F[l - 1], mod - 2) % mod;        ans = ans * ksm(s, (n / l) * (m / l)) % mod;    &#125;    return ans;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    init();    int t;    cin &gt;&gt; t;    while (t--)    &#123;        cin &gt;&gt; n &gt;&gt; m;        cout &lt;&lt; calc(n, m) &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n欧拉定理幂级数取模\n矩阵快速幂\n#include &lt;bits/stdc++.h&gt;using namespace std;#define int long longconst int mod = 1e9 + 7;int n, k;struct matrix&#123;    int c[101][101];    matrix() &#123; memset(c, 0, sizeof(c)); &#125;&#125; A, ans;matrix operator*(matrix &amp;x, matrix &amp;y)&#123;    matrix t;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 1; j &lt;= n; j++)        &#123;            for (int k = 1; k &lt;= n; k++)            &#123;                t.c[i][j] = (t.c[i][j] + x.c[i][k] * y.c[k][j]) % mod;            &#125;        &#125;    &#125;    return t;&#125;void quickpow(int k)&#123;    // 初始化单位矩阵    for (int i = 1; i &lt;= n; i++)    &#123;        ans.c[i][i] = 1;    &#125;    while (k)    &#123;        if (k &amp; 1)        &#123;            ans = ans * A;        &#125;        A = A * A;        k &gt;&gt;= 1;    &#125;&#125;signed main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 1; j &lt;= n; j++)        &#123;            cin &gt;&gt; A.c[i][j];        &#125;    &#125;    quickpow(k);    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 1; j &lt;= n; j++)        &#123;            cout &lt;&lt; ans.c[i][j] &lt;&lt; &quot; &quot;;        &#125;        cout &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n\n","tags":["“算法”"]},{"title":"某周写题报告","url":"/posts/a443d63f/","content":"\n把某周做过的题稍微整理了一下，主要是DP，方便随时复习，也方便后人踩坑。\n\n\n\n\n1 完全背包 · 洛谷 P1616 疯狂的采药思路把「时间」看成背包容量，「价值」就是药草收益。每种药草可以无限次采集 ⇒ 完全背包。\n状态转移  \ndp[j] = max(dp[j], dp[j - h[i]] + w[i])\n\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;typedef long long ll;int h[N], w[N];const int M = 1e7 + 10;ll dp[M];int main()&#123;    int t, m;    scanf(&quot;%d%d&quot;, &amp;t, &amp;m);    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;h[i], &amp;w[i]);    &#125;    for (int i = 1; i &lt;= m; i++)    &#123;        for (int j = h[i]; j &lt;= t; j++)        &#123;            dp[j] = max(dp[j - h[i]] + w[i], dp[j]);        &#125;    &#125;    printf(&quot;%lld\\n&quot;, dp[t]);    return 0;&#125;\n\n\n2 混合背包 · 洛谷 P1833 樱花思路题目同时出现 01、多重、完全三种背包。\n\np[i] == 0 → 完全背包\np[i] &gt; 0  → 01 &#x2F; 多重背包\n\n状态转移完全背包：正序多重背包：拆成 01 后逆序\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;int t[N], w[N], p[N];int dp[1008];int main()&#123;    int h1, h2, m1, m2;    scanf(&quot;%d:%d %d:%d&quot;, &amp;h1, &amp;m1, &amp;h2, &amp;m2);    int n;    scanf(&quot;%d&quot;, &amp;n);    int ans = (m2 - m1) + (h2 - h1) * 60;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;t[i], &amp;w[i], &amp;p[i]);    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        if (p[i] == 0) //完全背包        &#123;            for (int j = t[i]; j &lt;= ans; j++)            &#123;                dp[j] = max(dp[j - t[i]] + w[i], dp[j]);            &#125;        &#125;        else //多重背包和01背包        &#123;            for (int k = 1; k &lt;= p[i]; k++)            &#123;                for (int j = ans; j &gt;= k * t[i]; j--)                &#123;                    dp[j] = max(dp[j - t[i]] + w[i], dp[j]);                &#125;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[ans]);    return 0;&#125;\n\n\n3 二维背包 · 洛谷 P1855 榨取kkksc03思路背包有两个限制维度：时间 &amp; 金钱 ⇒ 二维 01 背包。\n状态转移\ndp[j][k] = max(dp[j][k], dp[j - a[i]][k - b[i]] + 1)\n\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;int a[108], b[108];int dp[300][300];int main()&#123;    int n, m, t;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;t);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;a[i], &amp;b[i]);    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = m; j &gt;= a[i]; j--)        &#123;            for (int k = t; k &gt;= b[i]; k--)            &#123;                dp[j][k] = max(dp[j][k], dp[j - a[i]][k - b[i]] + 1);            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[m][t]);    return 0;&#125;\n\n\n4 分组背包 · 洛谷 P1757 通天之分组背包思路物品分多组，每组最多选一个 ⇒ 经典分组背包。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e4 + 10;int cnt[N];int dp[N];int a[N], b[N];int vis[N][N];int main()&#123;    int m, n;    scanf(&quot;%d%d&quot;, &amp;m, &amp;n);    int ans;    int maxn = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;a[i], &amp;b[i], &amp;ans);        ++cnt[ans];        vis[ans][cnt[ans]] = i;        maxn = max(maxn, ans);    &#125;    for (int i = 1; i &lt;= maxn; i++)    &#123;        for (int j = m; j &gt;= 0; j--)        &#123;            for (int k = 1; k &lt;= cnt[i]; k++)            &#123;                if (j &gt;= a[vis[i][k]])                &#123;                    dp[j] = max(dp[j], dp[j - a[vis[i][k]]] + b[vis[i][k]]);                &#125;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[m]);    return 0;&#125;\n\n\n5 带附件的 01 背包 · 洛谷 P1064 [NOIP2006 提高组] 金明的预算方案思路每个主件最多带 2 个附件，决策从 2 种变成 5 种：不选、只选主件、主件 + 附件1、主件 + 附件2、主件 + 全部附件。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 4e4 + 10;int dpmainv[N], dpmainw[N];int dpannexv[N][3], dpannexw[N][3];int cnt[N];int dp[N];int main()&#123;    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    int a, b, q;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;q);        if (q == 0)        &#123;            dpmainv[i] = a;            dpmainw[i] = a * b;        &#125;        else        &#123;            cnt[q]++;            dpannexv[q][cnt[q]] = a;            dpannexw[q][cnt[q]] = a * b;        &#125;    &#125;    for (int i = 1; i &lt;= m; i++)    &#123;        for (int j = n; j &gt;= dpmainv[i] &amp;&amp; dpmainv[i] &gt; 0; j--)        &#123;            dp[j] = max(dp[j], dp[j - dpmainv[i]] + dpmainw[i]);            if (j &gt;= dpmainv[i] + dpannexv[i][1])            &#123;                dp[j] = max(dp[j], dp[j - dpmainv[i] - dpannexv[i][1]] + dpmainw[i] + dpannexw[i][1]);            &#125;            if (j &gt;= dpmainv[i] + dpannexv[i][2])            &#123;                dp[j] = max(dp[j], dp[j - dpmainv[i] - dpannexv[i][2]] + dpmainw[i] + dpannexw[i][2]);            &#125;            if (j &gt;= dpmainv[i] + dpannexv[i][1] + dpannexv[i][2])            &#123;                dp[j] = max(dp[j], dp[j - dpmainv[i] - dpannexv[i][1] - dpannexv[i][2]] + dpmainw[i] + dpannexw[i][1] + dpannexw[i][2]);            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, dp[n]);    return 0;&#125;\n\n\n6 树形 DP · 洛谷 P1352 没有上司的舞会思路树上做 01 背包：\n\ndp[u][0] 不参加，儿子可选可不选\ndp[u][1] 参加，儿子不能参加\n\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 6e3 + 10;int a[N];int dp[N][2];int vis[N];vector&lt;int&gt; v[N];void dfs(int ans)&#123;    dp[ans][1] = a[ans];    for (int i = 0; i &lt; v[ans].size(); i++)    &#123;        int cnt = v[ans][i];        dfs(cnt);                                  //往下遍历        dp[ans][0] += max(dp[cnt][0], dp[cnt][1]); //他的下属参加还是不参加        dp[ans][1] += dp[cnt][0];                  //此时下属不能参加    &#125;&#125;int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    int p, q;    for (int i = 1; i &lt;= n - 1; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;p, &amp;q);        v[q].push_back(p);        vis[p] = 1; //把职员标记上    &#125;    int ans = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        if (vis[i] == 0) //找最高职位，也就是树的根        &#123;            ans = i;            break;        &#125;    &#125;    dfs(ans);    printf(&quot;%d\\n&quot;, max(dp[ans][0], dp[ans][1]));    return 0;&#125;\n\n\n7 区间 DP · 能量项链思路环形合并石子模板：枚举长度 → 枚举左端点 → 枚举断点。\n代码\n#include &lt;iostream&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;const int N = 2e2 + 10;int a[N];int dp[N][N];int main()&#123;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        a[i + n] = a[i];    &#125;    // 2 3 5 10 2 3 5 10    //还是环形石子问题    for (int len = 3; len &lt;= n + 1; len++) //最少要三个值才能聚合两个珠子，但最后一个值最后还会用到    &#123;        for (int l = 1; l + len - 1 &lt;= 2 * n; l++)        &#123;            int r = l + len - 1;            for (int k = l + 1; k &lt; r; k++) //由于每颗珠子分首尾，所以k最小也得是l+1            &#123;                dp[l][r] = max(dp[l][r], dp[l][k] + dp[k][r] + a[l] * a[k] * a[r]); //由于k位置这个元素会重复用到，所以不用加一！！！            &#125;        &#125;    &#125;    int maxn = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        maxn = max(maxn, dp[i][n + i]);        // printf(&quot;%d\\n&quot;, dp[i][i + n]);    &#125;    printf(&quot;%d\\n&quot;, maxn);    return 0;&#125;\n\n\n8 第 k 优解 · HDU 2639思路在 01 背包基础上多开一维 dp[j][k] 记录体积为 j 时的前 k 大值。\n核心技巧每次用归并排序思想把两条链（选&#x2F;不选）的前 k 大合并。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e3 + 10;int dp[N][N];int a[108], b[108];int c[108], d[108];int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    &#123;        memset(dp, 0, sizeof(dp));        memset(c, 0, sizeof(c));        memset(d, 0, sizeof(d));        int n, v, p;        scanf(&quot;%d%d%d&quot;, &amp;n, &amp;v, &amp;p);        for (int i = 1; i &lt;= n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;a[i]);        &#125;        for (int i = 1; i &lt;= n; i++)        &#123;            scanf(&quot;%d&quot;, &amp;b[i]);        &#125;        for (int i = 1; i &lt;= n; i++)        &#123;            for (int j = v; j &gt;= b[i]; j--)            &#123;                for (int k = 1; k &lt;= p; k++)                &#123;                    c[k] = dp[j][k]; //体积为j时的第k大价值                    d[k] = dp[j - b[i]][k] + a[i];                &#125;                int q = 1, l = 1, r = 1;                while (q &lt;= p &amp;&amp; (l &lt;= p || r &lt;= p))                &#123;                    if (c[l] &gt;= d[r]) //比较两个数的大小，谁大就用谁赋值                    &#123;                        dp[j][q] = c[l++];                    &#125;                    else                    &#123;                        dp[j][q] = d[r++];                    &#125;                    if (dp[j][q] != dp[j][q - 1]) //这里要去一下重                    &#123;                        q++;                    &#125;                &#125;            &#125;        &#125;        printf(&quot;%d\\n&quot;, dp[v][p]);    &#125;    return 0;&#125;\n\n\n9 线段树&#x2F;搜索 · HDU 5323思路根据父子区间关系做 DFS，剪枝：右端点大于当前答案或左端点越界时返回。\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;typedef long long ll;ll ans;void dfs(ll l, ll r) //建立左区间和右区间递归搜索&#123;    if (l == 0)    &#123;        if (r != 0)        &#123;            ans = min(ans, r);        &#125;    &#125;    if (r &gt;= ans) //右边界    &#123;        return;    &#125;    if (l - 1 - (r - l) &lt; 0) //左边界    &#123;        return;    &#125;    dfs(l - 1 - (r - l), r); //奇数区间    dfs(l, r + 1 + r - l);    dfs(l - 1 - (r - l) - 1, r); //偶数区间    dfs(l, r + 1 + r - l - 1);&#125;int main()&#123;    ll l, r;    while (scanf(&quot;%lld%lld&quot;, &amp;l, &amp;r) != EOF)    &#123;        ans = 0x3f3f3f3f;        dfs(l, r);        if (l == 0 &amp;&amp; r == 0)        &#123;            printf(&quot;0\\n&quot;);        &#125;        else        &#123;            if (ans == 0x3f3f3f3f)            &#123;                printf(&quot;-1\\n&quot;);            &#125;            else            &#123;                printf(&quot;%lld\\n&quot;, ans);            &#125;        &#125;    &#125;    return 0;&#125;","categories":["算法"],"tags":["算法","动态规划","背包","线段树 ，搜索"]},{"title":"数位DP","url":"/posts/a3781d1f/","content":"数字游戏[https://vjudge.net/problem/LibreOJ-10164]: \n题目大意：科协里最近很流行数字游戏。\n某人命名了一种不降数，这种数字必须满足从左到右各位数字呈非下降关系，如 123，446。\n现在大家决定玩一个游戏，指定一个整数闭区间 [a,b]，问这个区间内有多少个不降数。\n输入格式输入包含多组测试数据。\n每组数据占一行，包含两个整数 a 和 b。\n输出格式每行给出一组测试数据的答案，即 [a,b] 之间有多少不降数。\n数据范围1≤ a ≤ b ≤2^31−1\n解题思路：f[i][j] 数组代表着最高位是j并且一共有i位不降数的集合f[i][j] &#x3D; f[i-1][j] + f[i-1][j+1] + f[i-1][j+2] +…+ f[i-1][9];\n按照数位DP分析步骤： 假设我们当前枚举到第i位，且第i位上的数字是x，那么现在对于答案的第i位数字j来说，可以填两类数字：\n1.j 取0~x-1 那么res +&#x3D; f[i+1][j];\n2.j 取 x last记录x，再枚举下一位\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 12;int a[N];    //存整数的每一位数字int f[N][N]; // f[i][j]表示一共有i位，且最高为数字是j的不降数的个数void init()  //预处理不降数的个数&#123;    for (int i = 0; i &lt;= 9; i++)    &#123;        f[1][i] = 1; //一位数就是1    &#125;    for (int i = 2; i &lt; N; i++) //阶段：枚举位数    &#123;        for (int j = 0; j &lt;= 9; j++) //状态：枚举最高位        &#123;            for (int k = j; k &lt;= 9; k++) //决策：枚举次高位            &#123;                f[i][j] += f[i - 1][k]; //累加所有方案数            &#125;        &#125;    &#125;&#125;int dp(int n)&#123;    if (n == 0) //特判，n=0就一个数字    &#123;        return 1;    &#125;    int cnt = 0;    while (n)    &#123;        a[++cnt] = n % 10; //从低到高存每一位数        n /= 10;    &#125;    int ans = 0;    int last = 0;                  // last表示上一位数字    for (int i = cnt; i &gt;= 1; i--) //从高到低依次枚举    &#123;        int now = a[i];                  // now表示当前位数字        for (int j = last; j &lt; now; j++) //枚举当前为可填入的数字        &#123;            ans += f[i][j]; //累加方案数        &#125;        if (now &lt; last) //若比上一位小，直接退出        &#123;            break;        &#125;        last = now; //更新last的值        if (i == 1) //走到a1时，最后会少加一个右边界数，要加一        &#123;            ans++;        &#125;    &#125;    return ans;&#125;int main()&#123;    init();    int l, r;    while (cin &gt;&gt; l &gt;&gt; r)    &#123;        printf(&quot;%d\\n&quot;, dp(r) - dp(l - 1));    &#125;    return 0;&#125;\n\nwindy数[https://www.luogu.com.cn/problem/P2657]: \n题意：windy定义了一种windy数。\n不含前导零且相邻两个数字之差至少为2的正整数被称为windy数。\nwindy想知道，在A和B之间，包括A和B，总共有多少个windy数？\nInput\n包含两个整数，A，B。\n满足1≤A≤B≤2000000000 .\nSample 1\n\n\n\nInput\nOutput\n\n\n\n1 10\n9\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 12;int a[N];    //存整数的每一位数字int f[N][N]; // f[i][j]表示一共有i位，且最高为数字是j的不降数的个数void init()  //预处理不降数的个数&#123;    for (int i = 0; i &lt;= 9; i++)    &#123;        f[1][i] = 1; //一位数就是1    &#125;    for (int i = 2; i &lt; N; i++) //阶段：枚举位数    &#123;        for (int j = 0; j &lt;= 9; j++) //状态：枚举最高位        &#123;            for (int k = 0; k &lt;= 9; k++) //决策：枚举次高位            &#123;                if (abs(j - k) &gt;= 2)                &#123;                    f[i][j] += f[i - 1][k];                &#125;            &#125;        &#125;    &#125;&#125;int dp(int n)&#123;    if (n == 0) //特判，n=0就一个数字    &#123;        return 0;    &#125;    int cnt = 0;    while (n)    &#123;        a[++cnt] = n % 10; //从低到高存每一位数        n /= 10;    &#125;    int ans = 0;    int last = -2;                 // last表示上一位数字    for (int i = cnt; i &gt;= 1; i--) //从高到低依次枚举    &#123;        int now = a[i];        for (int j = (i == cnt); j &lt; now; j++)        &#123;            if (abs(j - last) &gt;= 2)            &#123;                ans += f[i][j];            &#125;        &#125;        if (abs(now - last) &lt; 2) //若比上一位小，直接退出        &#123;            break;        &#125;        last = now; //更新last的值        if (i == 1) //走到a1时，最后会少加一个右边界数，要加一        &#123;            ans++;        &#125;    &#125;    //前面算的都是cnt位的    //需要加上小于cnt位的数    for (int i = 1; i &lt; cnt; i++)    &#123;        for (int j = 1; j &lt;= 9; j++) //不能有前导0        &#123;            ans += f[i][j];        &#125;    &#125;    return ans;&#125;int main()&#123;    init();    int l, r;    cin &gt;&gt; l &gt;&gt; r;    printf(&quot;%d\\n&quot;, dp(r) - dp(l - 1));    return 0;&#125;\n\nacwing1081：度的数量\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 35;int a[N];    //把b进制的每一位数存起来int f[N][N]; // f[i][j]表示在i个位置上，放置j个1的组合数int k, b;void init()&#123;    for (int i = 0; i &lt; N; i++) //预处理组合数    &#123;        f[i][0] = 1;    &#125;    for (int i = 1; i &lt; N; i++)    &#123;        for (int j = 1; j &lt;= i; j++)        &#123;            f[i][j] += f[i - 1][j] + f[i - 1][j - 1];        &#125;    &#125;    // c(j,i)=c(j-1,i-1)+c(j,i-1);&#125;int dp(int n)&#123;    if (n == 0) //特判，n==0返回0    &#123;        return 0;    &#125;    int cnt = 0;    while (n) //把b进制数的每一位存入数组    &#123;        a[++cnt] = n % b;        n /= b;    &#125;    int ans = 0, last = 0;         // last表示第i位之前放置的1    for (int i = cnt; i &gt;= 1; i--) //从高位到低位枚举    &#123;        int x = a[i];        if (x) //第i位==0时，直接跳过，枚举下一位        &#123;            ans += f[i - 1][k - last]; //第i位放0            if (x &gt; 1)            &#123;                if (k - (last + 1) &gt;= 0)                &#123;                    ans += f[i - 1][k - (last + 1)]; //第i位放1                    break;                           //第i位放大于1的数，不符合题意，直接退出                &#125;            &#125;            else //第i位等于1时，后面不能用组合数计算，比如65转换成4进制是1001，如果用组合数计算会出现比65大的值，所以应继续向下枚举            &#123;                last += 1;                if (last &gt; k) // 1的个数多于k，则break                &#123;                    break;                &#125;            &#125;        &#125;        if (i == 1 &amp;&amp; last == k) //判断末位是否符合题意        &#123;            ans++;        &#125;    &#125;    return ans;&#125;int main()&#123;    init();    int l, r;    scanf(&quot;%d%d&quot;, &amp;l, &amp;r);    scanf(&quot;%d&quot;, &amp;k);    scanf(&quot;%d&quot;, &amp;b);    printf(&quot;%d\\n&quot;, dp(r) - dp(l - 1));    return 0;&#125;\n","tags":["算法"]},{"title":"牛客小白月赛60","url":"/posts/ec03080e/","content":"A. 小竹与妈妈\n题意\nay+b&#x3D;x, 已知a,b,x,求y\n\n\n题解\n显然小竹的年龄为  直接输出即可。\n\n\n代码\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    long long a, b, x;    scanf(&quot;%lld%lld%lld&quot;, &amp;a, &amp;b, &amp;x);    printf(&quot;%lld\\n&quot;, (x - b) / a);    return 0;&#125;\n\nB.走丢的小竹\n题意\n\n有 n 个出口，每个出口都连着 m 个房间其中一个，有 q 次询问，每次都问如果不能去 x 号房间的话，有多少出口能走。\n1≤n,m,q≤105\n\n\n\n题解\n\n记录每个房间有多少个出口连接记为,每次询问输出即可。\n\n\n代码\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e5 + 10;int a[N];int main()&#123;    int n, m, q;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;q);    map&lt;int, int&gt; mp;    // set&lt;int&gt; s;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        mp[a[i]]++;        // s.insert(a[i]);    &#125;    while (q--)    &#123;        int ans;        scanf(&quot;%d&quot;, &amp;ans);        printf(&quot;%d\\n&quot;, n - mp[ans]);    &#125;    return 0;&#125;\n\nC.小竹关禁闭\n题意\n\n有 n 个绳子，第 i 条绳子长度为 ai ，当你使用第 i 条绳子的时候，后面的 k 条绳子就都不能用了，问能拿到的所有绳子长度总和最大是多少。\n\n\n题解\n\n用一个  的  即可解决该问题。设  为选择前  个数绳子的最大长度。\n很容易能列出  。\n由于允许  通过,直接模拟该过程即。最后的答案为。\n\n\n\n代码1 从前往后推\n#include &lt;bits/stdc++.h&gt;using namespace std;int n, k;int a[2005];int dp[2005];int ans;int main()&#123;    cin &gt;&gt; n &gt;&gt; k;    for (int i = 1; i &lt;= n; ++i)    &#123;        cin &gt;&gt; a[i];    &#125;    for (int i = 1; i &lt;= n; ++i)        for (int j = 0; j &lt;= max(0, i - k - 1); ++j)        &#123;            dp[i] = max(dp[j] + a[i], dp[i]);            ans = max(ans, dp[i]);        &#125;    cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n代码2 从后往前推\n\n\n#include &lt;bits/stdc++.h&gt; using namespace std;const int N = 2e3 + 10;int a[N];int dp[N];int main()&#123;    int n, k;    scanf(&quot;%d%d&quot;, &amp;n, &amp;k);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    // dp[0][0] = dp[0][1] = 0;    // dp[1][1] = a[1];    // dp[1][0] = 0;    int maxn = 0;    for (int i = n; i &gt;= 1; i--)    &#123;        dp[i] = max(dp[i + 1], dp[min(n + 1, i + k + 1)] + a[i]);        maxn = max(maxn, dp[i]);    &#125;    printf(&quot;%d\\n&quot;, maxn);    return 0;&#125;\n\n\n\nD. 游戏购买！\n题意\n\n有一个 n∗m 的矩阵，矩阵上有数值。玩家当前分数为 0 ，想从 (sx,sy) 走到 (ex,ey) ，每一步都可以将自己的分数更新为当前所在位置的数值。问想从(sx,sy) 走到 (ex,ey) ，且分数超过 x 需要的最小步数是多少。\n\n\n题解\n\n从起点开始  求出起点到每个位置的最短路,从终点开始同样跑一遍  求出终点到每个位置的最短路.对于每一个拥有刺激度高于  游戏的店铺  ,要经过该店铺的答案即为起点到  的最短路,加上终点到  的最短路\n\n\n代码\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#pragma GCC optimize(2)const int N = 2e3 + 10;int a[N][N];int ans;int n, m;int sx, sy, ex, ey;int sum = 0;int dx[] = &#123;0, 0, 1, -1&#125;;int dy[] = &#123;1, -1, 0, 0&#125;;int vis[N][N];int xx, yy;int dis1[N][N];int dis2[N][N];struct node&#123;    int x, y, cnt;&#125;;void bfs1(int x, int y)&#123;    dis1[x][y] = 0;    queue&lt;node&gt; q;    q.push(&#123;x, y, 0&#125;);    vis[x][y] = 1;    while (!q.empty())    &#123;        node t = q.front();        q.pop();        for (int i = 0; i &lt; 4; i++)        &#123;            int xx = t.x + dx[i];            int yy = t.y + dy[i];            if (vis[xx][yy] == 0 &amp;&amp; xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m &amp;&amp; a[xx][yy] != -1)            &#123;                vis[xx][yy] = 1;                node p;                p.x = xx;                p.y = yy;                p.cnt = t.cnt + 1;                dis1[xx][yy] = p.cnt;                q.push(p);            &#125;        &#125;    &#125;&#125;void bfs2(int x, int y)&#123;    dis2[x][y] = 0;    queue&lt;node&gt; q;    q.push(&#123;x, y, 0&#125;);    vis[x][y] = 1;    while (!q.empty())    &#123;        node t = q.front();        q.pop();        for (int i = 0; i &lt; 4; i++)        &#123;            int xx = t.x + dx[i];            int yy = t.y + dy[i];            if (vis[xx][yy] == 0 &amp;&amp; xx &gt;= 1 &amp;&amp; xx &lt;= n &amp;&amp; yy &gt;= 1 &amp;&amp; yy &lt;= m &amp;&amp; a[xx][yy] != -1)            &#123;                vis[xx][yy] = 1;                node p;                p.x = xx;                p.y = yy;                p.cnt = t.cnt + 1;                dis2[xx][yy] = p.cnt;                q.push(p);            &#125;        &#125;    &#125;&#125;int main()&#123;    scanf(&quot;%d%d%d&quot;, &amp;n, &amp;m, &amp;ans);    scanf(&quot;%d%d%d%d&quot;, &amp;sx, &amp;sy, &amp;ex, &amp;ey);    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 1; j &lt;= m; j++)        &#123;            scanf(&quot;%d&quot;, &amp;a[i][j]);        &#125;    &#125;    memset(vis, 0, sizeof(vis));    bfs1(sx, sy);    memset(vis, 0, sizeof(vis));    bfs2(ex, ey);    int minn = 0x3f3f3f3f;    int flag = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        for (int j = 1; j &lt;= m; j++)        &#123;            if (a[i][j] &gt; ans)            &#123;                if (dis1[i][j] == 0 || dis2[i][j] == 0)                &#123;                    continue;                &#125;                else                &#123;                    flag = 1;                    minn = min(minn, dis1[i][j] + dis2[i][j]);                &#125;            &#125;        &#125;    &#125;    if (flag == 1)    &#123;        printf(&quot;%d\\n&quot;, minn);    &#125;    else    &#123;        printf(&quot;-1\\n&quot;);    &#125;    return 0;&#125;\n\nE.寻找小竹！\n题意\n\n给定树上 n 个节点和 n−1 条边，如果一条边上的两个点存在至少两个不同的质因子，称这两个节点为共同优雅的。问整棵树上包含节点最多的共有优雅连通块有多少个节点。\n\n\n题解\n\n相邻结点满足有至少两个不同的共同质因子,也就相当于,相邻两个结点的  满足不为任何质数的幂次,且不为1\n我们可以把所有质数的幂次使用一个标记数组  标记起来,然后进行树形dp\n设  为以  为根的最大优雅联通块,设  为  的子节点的集合，则\n\n\n\n\n代码\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e6 + 10;int prime[N], cnt;int st[N];int a[N];int son[N];vector&lt;int&gt; e[N];int vis[N];int maxn = 0;void dfs(int u, int fa)&#123;    son[u] = 1;    for (auto t : e[u])    &#123;        if (t == fa)        &#123;            continue;        &#125;        dfs(t, u);        if (st[__gcd(a[u], a[t])] == 0)        &#123;            son[u] += son[t];        &#125;    &#125;    // maxn = max(son[u], maxn);&#125;void init(int n)&#123;    st[1] = 1;    for (int i = 2; i &lt;= n; i++)    &#123;        if (!vis[i])        &#123;            for (int j = i * 2; j &lt;= n; j += i)            &#123;                vis[j] = 1;            &#125;            for (long long j = i; j &lt;= n; j *= i)            &#123;                st[j] = 1;            &#125;        &#125;    &#125;&#125;int main()&#123;    init(N);    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);    &#125;    int p, q;    for (int i = 1; i &lt;= n - 1; i++)    &#123;        scanf(&quot;%d%d&quot;, &amp;p, &amp;q);        e[p].push_back(q);        e[q].push_back(p);    &#125;    dfs(1, 0);    for (int i = 1; i &lt;= n; i++)    &#123;        maxn = max(son[i], maxn);    &#125;    printf(&quot;%d\\n&quot;, maxn);    return 0;&#125;\n\nF.被抓住的小竹\n题意\n题解\n\n\n\n代码\n\n#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longint t;int n;vector&lt;int&gt; js;const int mod = 1e9 + 7;ll fac[100006];ll ifac[100006];int maxn = 1e5 + 4;ll ksm(ll x, ll y)&#123;    ll ans = 1;    while (y)    &#123;        if (y &amp; 1)        &#123;            ans = ans * x % mod;        &#125;        y &gt;&gt;= 1;        x = x * x % mod;    &#125;    return ans;&#125;void init()&#123;    fac[0] = 1;    for (int i = 1; i &lt;= maxn; i++)    &#123;        fac[i] = fac[i - 1] * i % mod;    &#125;    // ifac[1] = 1;    // for (int i = 2; i &lt;= maxn; i++)    // &#123;    //     ifac[i] = (ll)(mod - mod / i) * ifac[mod % i] % mod;    // &#125;    ifac[maxn - 1] = ksm(fac[maxn - 1], mod - 2);    for (int i = maxn - 1; i &gt;= 1; i--)    &#123;        ifac[i - 1] = ifac[i] * i % mod;    &#125;&#125;ll C(ll x, ll y)&#123;    return fac[x] * ifac[y] % mod * ifac[x - y] % mod;&#125;int main()&#123;    init();    int t;    cin &gt;&gt; t;    while (t--)    &#123;        int n;        cin &gt;&gt; n;        ll ans = (((C(n + 3, 4)) % mod * fac[(n - 2)] % mod * (1ll * n * (n - 1) / 2) % mod * (1ll * n * (n - 1) / 2) % mod)) % mod;        cout &lt;&lt; ans &lt;&lt; &#x27;\\n&#x27;;    &#125;    return 0;&#125;\n","tags":["算法"]},{"title":"牛客小白月赛59","url":"/posts/bef2e369/","content":"A.我会开摆\n题意\n给定n&#x3D;4的方阵，问是否存在n&#x3D;2的方阵中四个格子全是一个字符的情况\n\n\n题解\n直接枚举所有点当n&#x3D;2方阵的左上角，看是否符合题目要求\n注意：检查n&#x3D;2的方阵时，要先排除某点为左上角没有n&#x3D;2方阵情况\n\n\n代码\n\n#include &lt;bits/stdc++.h&gt;using namespace std;char a[5][5];int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    &#123;        for (int i = 1; i &lt;= 4; i++)        &#123;            for (int j = 1; j &lt;= 4; j++)            &#123;                cin &gt;&gt; a[i][j];            &#125;        &#125;        int flag = 0;        for (int i = 1; i &lt;= 3; i++)        &#123;            for (int j = 1; j &lt;= 3; j++)            &#123;                if (a[i][j] == &#x27;.&#x27; &amp;&amp; a[i][j + 1] == &#x27;.&#x27; &amp;&amp; a[i + 1][j] == &#x27;.&#x27; &amp;&amp; a[i + 1][j + 1] == &#x27;.&#x27;)                &#123;                    flag = 1;                    break;                &#125;                if (a[i][j] == &#x27;#&#x27; &amp;&amp; a[i][j + 1] == &#x27;#&#x27; &amp;&amp; a[i + 1][j] == &#x27;#&#x27; &amp;&amp; a[i + 1][j + 1] == &#x27;#&#x27;)                &#123;                    flag = 1;                    break;                &#125;            &#125;            if (flag == 1)            &#123;                break;            &#125;        &#125;        if (flag == 1)        &#123;            printf(&quot;Yes\\n&quot;);        &#125;        else        &#123;            printf(&quot;No\\n&quot;);        &#125;    &#125;    return 0;&#125;\n\nB.走廊的灯\n题意\n路上有n盏灯，0代表灭的，1代表亮的，2代表闪烁，可以看成灭的也可以看成亮的\n问最长的状态一样的连续的灯的数量为多少\n\n\n题解\n暴力，分两次遍历，第一次把2全部当作0，第二次把2全部当作1，找出最长的连续段即可\n\n\n代码\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int main()&#123;    int t;    scanf(&quot;%d&quot;, &amp;t);    while (t--)    &#123;        int n;        scanf(&quot;%d&quot;, &amp;n);        string a;        cin &gt;&gt; a;        int len = a.size();        int sum = 0;        int maxn = 0;        for (int i = 0; i &lt; len; i++)        &#123;            if (a[i] != &#x27;0&#x27;)            &#123;                sum++;            &#125;            else            &#123;                sum = 0;            &#125;            maxn = max(maxn, sum);        &#125;        sum = 0;        for (int i = 0; i &lt; len; i++)        &#123;            if (a[i] != &#x27;1&#x27;)            &#123;                sum++;            &#125;            else            &#123;                sum = 0;            &#125;            maxn = max(maxn, sum);        &#125;        printf(&quot;%d\\n&quot;, maxn);    &#125;    return 0;&#125;\n\nC.输出练习\n题意\n从小到大输出区间[l,r]中，k的非负整数次方的值\nl,r,k范围 [0,2^63)\n\n\n题解\n除去特例的0,1；当k&#x3D;2时，l&#x3D;0,r&#x3D;2^63-1，会有最多个输出，也才64个。所以直接暴力即可\n注意特判。k&#x3D;1时，直接输出1即可，否则暴力和会炸；k&#x3D;0时，0^0&#x3D;1,但是0^1&#x3D;0,0^2&#x3D;0，即如果区间符合要求，那么k&#x3D;0会有两个输出。麻麻麻这里WA麻了，好无语\n注意数据范围，while(k&lt;&#x3D;r)这样写会爆long long，所以我这里用java逃课\n\n\n代码\n\nimport java.math.BigInteger;import java.util.Scanner;public class Main &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        int t = sc.nextInt();        while (t-- &gt; 0) &#123;            BigInteger l, r, k;            l = sc.nextBigInteger();            r = sc.nextBigInteger();            k = sc.nextBigInteger();            BigInteger p = new BigInteger(&quot;0&quot;);            BigInteger q = new BigInteger(&quot;1&quot;);            boolean fuck = true;            StringBuilder sb = new StringBuilder();            if (k.compareTo(p) == 0) &#123;                if (l.compareTo(p) &lt;= 0) &#123;                    sb.append(0+&quot; &quot;);                    fuck = false;                &#125;            &#125;            if (l.compareTo(q) &lt;= 0 &amp;&amp; r.compareTo(q) &gt;= 0) &#123;                sb.append(1 + &quot; &quot;);                fuck = false;            &#125;            BigInteger pos=k;            if (k.compareTo(p) != 0 &amp;&amp; k.compareTo(q) != 0) &#123;                while (r.compareTo(k) &gt;= 0) &#123;                    if (l.compareTo(k) &lt;= 0 &amp;&amp; r.compareTo(k) &gt;= 0) &#123;                        sb.append(k + &quot; &quot;);                        fuck = false;                    &#125;                    k=k.multiply(pos);                &#125;            &#125;            if(fuck)            &#123;                System.out.println(&quot;None.&quot;);            &#125;else&#123;                System.out.println(sb);            &#125;        &#125;    &#125;&#125;\n\nD.国际象棋\n题意\n\n竖直放置的n*m的棋盘，每次选一列放一枚棋子，重力原因棋子落到最下面\n对于第i个放置的棋子，i为奇数时，其所放的颜色为黑色，偶数为白色棋子\nk子连珠定义为：横竖撇捺四个方向存在某个方向有k个相同颜色棋子\n一共放t颗棋子，若出现k子连珠则游戏结束，保证有解，问游戏结束时放置了多少棋子\n\n\n题解\n\n模拟题。\n水平方向，竖直方向，两个斜方向分别枚举看是否符合条件即可\n\n\n代码\n\n\n#include &lt;bits/stdc++.h&gt;using namespace std;int n, m, k, t;char a[1008][1008];int judge(int x, int y)&#123;    if (x &gt;= 1 &amp;&amp; x &lt;= n &amp;&amp; y &gt;= 1 &amp;&amp; y &lt;= m)    &#123;        return 1;    &#125;    else    &#123;        return 0;    &#125;&#125;int solve(int x, int y, int ch)&#123;    //横    int sum = 1;    int xx = x, yy = y - 1;    while (1)    &#123;        if (!judge(xx, yy))        &#123;            break;        &#125;        if (a[xx][yy] == ch)        &#123;            sum += 1;            if (sum &gt;= k)            &#123;                return 1;            &#125;        &#125;        else        &#123;            break;        &#125;        yy--;    &#125;    xx = x, yy = y + 1;    while (1)    &#123;        if (!judge(xx, yy))        &#123;            break;        &#125;        if (a[xx][yy] == ch)        &#123;            sum += 1;            if (sum &gt;= k)            &#123;                return 1;            &#125;        &#125;        else        &#123;            break;        &#125;        yy++;    &#125;    //竖    sum = 1;    xx = x + 1, yy = y;    while (1)    &#123;        if (!judge(xx, yy))        &#123;            break;        &#125;        if (a[xx][yy] == ch)        &#123;            sum += 1;            if (sum &gt;= k)            &#123;                return 1;            &#125;        &#125;        else        &#123;            break;        &#125;        xx++;    &#125;    //左斜    sum = 1;    xx = x - 1, yy = y - 1;    while (1)    &#123;        if (!judge(xx, yy))        &#123;            break;        &#125;        if (a[xx][yy] == ch)        &#123;            sum += 1;            if (sum &gt;= k)            &#123;                return 1;            &#125;        &#125;        else        &#123;            break;        &#125;        xx--, yy--;    &#125;    xx = x + 1, yy = y + 1;    while (1)    &#123;        if (!judge(xx, yy))        &#123;            break;        &#125;        if (a[xx][yy] == ch)        &#123;            sum += 1;            if (sum &gt;= k)            &#123;                return 1;            &#125;        &#125;        else        &#123;            break;        &#125;        xx++, yy++;    &#125;    //右斜    sum = 1;    xx = x + 1, yy = y - 1;    while (1)    &#123;        if (!judge(xx, yy))        &#123;            break;        &#125;        if (a[xx][yy] == ch)        &#123;            sum += 1;            if (sum &gt;= k)            &#123;                return 1;            &#125;        &#125;        else        &#123;            break;        &#125;        xx++, yy--;    &#125;    xx = x - 1, yy = y + 1;    while (1)    &#123;        if (!judge(xx, yy))        &#123;            break;        &#125;        if (a[xx][yy] == ch)        &#123;            sum += 1;            if (sum &gt;= k)            &#123;                return 1;            &#125;        &#125;        else        &#123;            break;        &#125;        xx--, yy++;    &#125;    return 0;&#125;int main()&#123;    ios::sync_with_stdio(false);    cin.tie(0);    cout.tie(0);    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k &gt;&gt; t;    int ans;    int flag = 0;    int sum = 0;    int cnt = 0;    map&lt;int, int&gt; mp;    memset(a, &#x27;!&#x27;, sizeof(a));    while (t--)    &#123;        ++cnt;        cin &gt;&gt; ans;        if (flag == 0)        &#123;            sum++;            int x = n - mp[ans];            int y = ans;            mp[ans]++;            if (cnt % 2 == 1)            &#123;                a[x][y] = &#x27;1&#x27;;            &#125;            else            &#123;                a[x][y] = &#x27;0&#x27;;            &#125;            int pos = solve(x, y, a[x][y]);            if (pos == 1)            &#123;                flag = 1;            &#125;        &#125;    &#125;    printf(&quot;%d\\n&quot;, sum);    return 0;&#125;\n\nE.弹珠碰撞\n题意\n长度为n的线段上有m个弹珠，给定每个弹珠的方向左&#x2F;右，及坐标\n弹珠每秒走一个单位，发生碰撞会停滞一秒，且两珠方向互换，多次碰撞停滞时间叠加\n当弹珠走到0，或者n+1认为掉落\n问线段上最后掉落的弹珠掉出所花的时间\n\n\n题解\n碰撞转向直接看成穿过就好了，因为弹珠之间没有区别\n以某个向左走于位置i的弹珠为例，没有碰撞时时间为i-0，有碰撞需要记录在i左边且方向向右的弹珠数r，时间为i-0+r，从左往右边遍历遍记录答案和数量即可。某个向右走于位置i的弹珠，n+1-i+l，注意这里是逆序遍历。\n这类题经常就是这样的写法，相当于固定题型了\n\n\n代码\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;int d[N], p[N];int pos[N];int main()&#123;    memset(pos, -1, sizeof(pos));    int n, m;    scanf(&quot;%d%d&quot;, &amp;n, &amp;m);    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d&quot;, &amp;d[i]);    &#125;    for (int i = 1; i &lt;= m; i++)    &#123;        scanf(&quot;%d&quot;, &amp;p[i]);        pos[p[i]] = d[i];    &#125;    int maxn = 0;    int ans = 0;    int cnt = 0;    for (int i = 1; i &lt;= n; i++)    &#123;        if (pos[i] == -1)        &#123;            continue;        &#125;        else if (pos[i] == 0)        &#123;            maxn = max(maxn, i - 0 + ans);        &#125;        else if (pos[i] == 1)        &#123;            ans += 1;        &#125;    &#125;    for (int i = n; i &gt;= 1; i--)    &#123;        if (pos[i] == -1)        &#123;            continue;        &#125;        else if (pos[i] == 1)        &#123;            maxn = max(maxn, n + 1 - i + cnt);        &#125;        else if (pos[i] == 0)        &#123;            cnt += 1;        &#125;    &#125;    printf(&quot;%d\\n&quot;, cnt);    return 0;&#125;\n\nF.困难卷积\n题意\n\n\n\n题解\ntrick题。如果我们直接暴力枚举两个数组，复杂度为O(n^2)炸了\n观察数据范围特征，数组的和范围在1e7以内，那么考虑与种类数有关，因为贪心构造一个数种类多的数组为0 1 … x，等差数列求和得到x&#x3D;sqrt(2e7)，即数组中最多有sqrt(2e7)种数，此时遍历的复杂度已经降低了，所以开始考虑如何计算答案\n以同种类数分别分组a,b后，我们可以得到数num及其出现的次数cnt。那么对于某一组别a1和某一组别b1对于答案的贡献为(a1.cnt * b1.cnt * floor(sqrt(差))，那么只需要枚举a分组和b分组，时间复杂度为O(sqrt(2e7)^2)&#x3D;O(2e7)\n\n\n代码\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 1e6 + 10;int a[N], b[N];int main()&#123;    map&lt;int, int&gt; m1, m2;    int n;    scanf(&quot;%d&quot;, &amp;n);    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;a[i]);        m1[a[i]]++;    &#125;    for (int i = 1; i &lt;= n; i++)    &#123;        scanf(&quot;%d&quot;, &amp;b[i]);        m2[b[i]]++;    &#125;    long long sum = 0;    for (auto i : m1)    &#123;        for (auto j : m2)        &#123;            long long ans = sqrt(abs(i.first - j.first));            sum += i.second * j.second * ans;        &#125;    &#125;    printf(&quot;%lld\\n&quot;, sum);    return 0;&#125;\n","tags":["算法"]},{"title":"组合数学","url":"/posts/7ff86023/","content":"1.杨辉三角递推法求组合数设 $C[i][j]$ 为已在 $i$个元素中抽取了 $j$ 个元素，对于上一步描述，有可能是：这一步没有抽取元素，之前已经抽了 $j$ 个元素：$C[i-1][j]$这一步抽取了一个元素，之前已经抽了 $j-1$ 个元素：$C[i-1][j-1]$将这两种情况加起来便是 $C[i][j]$ 的结果，由此得出式子：$C[i][j] &#x3D; C[i-1][j] + C[i-1][j-1]$\n时间复杂度：$O(n^2)$\n核心代码\nvoid getC(int N)&#123;    for (int i = 0; i &lt;= N; i++)    &#123;        for (int j = 0; j &lt;= i; j++)        &#123;            if (j == 0)            &#123;                C[i][j] = 1;            &#125;            else            &#123;                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;            &#125;        &#125;    &#125;&#125;\n\n\n\n\n\n$i\\backslash j$\n0\n1\n2\n3\n4\n5\n6\n\n\n\n0\n1\n\n\n\n\n\n\n\n\n1\n1\n1\n\n\n\n\n\n\n\n2\n1\n2\n1\n\n\n\n\n\n\n3\n1\n3\n3\n1\n\n\n\n\n\n4\n1\n4\n6\n4\n1\n\n\n\n\n5\n1\n5\n10\n10\n5\n1\n\n\n\n6\n1\n6\n15\n20\n15\n6\n1\n\n\n杨辉三角公式：\n$C_{n}^{0} &#x3D; C_{n}^{n} &#x3D; 1$$C_{n}^{m} &#x3D; C_{n}^{n-m}$$C_{n}^{m} &#x3D; C_{n-1}^{m} + C_{n-1}^{m-1}$\n计蒜客-T1984\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 2e3 + 10;int C[N][N];const int p = 1e9 + 7;void getC(int N)&#123;    for (int i = 0; i &lt;= N; i++)    &#123;        for (int j = 0; j &lt;= i; j++)        &#123;            if (j == 0)            &#123;                C[i][j] = 1;            &#125;            else            &#123;                C[i][j] = (C[i - 1][j] + C[i - 1][j - 1]) % p;            &#125;        &#125;    &#125;&#125;int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    getC(n);    cout &lt;&lt; C[n][m] &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n2.快速幂和乘法逆元求组合数递推法 $C_{n}^{m} &#x3D; C_{n-1}^{m} + C_{n-1}^{m-1}$ 会 TLE考虑用 $C_{n}^{m} &#x3D; \\dfrac{n!}{m!(n-m)!}$ 直接计算。用 $f[x]$ 存 $x! \\pmod{p}$ 的值，用 $g[x]$ 存 $\\dfrac{1}{x!} \\pmod{p}$ 的值。因为 $p$ 是质数且 $n,m$ 都小于 $p$，即 $n, m$ 与 $p$ 互质，所以根据费马小定理 $a \\cdot a^{p-2} \\equiv 1 \\pmod{p}$，$g[i] &#x3D; \\dfrac{1}{i!} \\pmod{p} &#x3D; \\dfrac{1}{i} \\times \\dfrac{1}{(i-1)!} \\pmod{p} &#x3D; \\text{qpow}(i,p-2) \\times g[i-1]$查询 $C_{n}^{m} \\pmod{p} &#x3D; f[n] \\cdot g[n-m] \\cdot g[m] \\pmod{p}$\n时间复杂度：$O(n \\log p)$\n核心代码\nint qpow(int a, int b)&#123;    int ans = 1;    while (b)    &#123;        if (b &amp; 1)        &#123;            ans = ans * a % p;        &#125;        a = a * a % p;        b &gt;&gt;= 1;    &#125;    return ans;&#125;void init(int n)&#123;    f[0] = g[0] = 1;    for (int i = 1; i &lt;= n; i++)    &#123;        f[i] = f[i - 1] * i % p;        g[i] = g[i - 1] * qpow(i, p - 2) % p;    &#125;&#125;int getC(int n, int m)&#123;    return f[n] * g[m] % p * g[n - m] % p;&#125;\n\n3.Lucas定理求组合数$C_{n}^{m} \\equiv C_{n&#x2F;p}^{m&#x2F;p} \\cdot C_{n \\bmod p}^{m \\bmod p} \\pmod{p}$引理1：$C_{p}^{x} \\equiv 0 \\pmod{p}$, $0&lt;x&lt;p$因 $C_{p}^{x} &#x3D; \\dfrac{p!}{x!(p-x)!} &#x3D; \\dfrac{p(p-1)!}{x(x-1)!(p-x)!} &#x3D; \\dfrac{p}{x} \\cdot C_{p-1}^{x-1}$故 $C_{p}^{x} \\equiv p \\cdot \\text{inv}(x) \\cdot C_{p-1}^{x-1} \\equiv 0 \\pmod{p}$引理2：$(1+x)^p \\equiv 1 + x^p \\pmod{p}$由二项式定理 $(1+x)^p &#x3D; \\sum\\limits_{i&#x3D;0}^{p} C_{p}^{i} x^i$由引理1知，只剩下i&#x3D;0,p这两项，得证\n时间复杂度：$O(p \\log p + \\log_p n)$\n核心代码\nint qpow(int a, int b, int p)&#123;    int ans = 1;    while (b)    &#123;        if (b &amp; 1)        &#123;            ans = ans * a % p;        &#125;        a = a * a % p;        b &gt;&gt;= 1;    &#125;    return ans;&#125;void init(int p)&#123;    f[0] = g[0] = 1;    for (int i = 1; i &lt;= p; i++)    &#123;        f[i] = f[i - 1] * i % p;        g[i] = g[i - 1] * qpow(i, p - 2, p) % p;    &#125;&#125;int getC(int n, int m, int p)&#123;    return f[n] * g[m] * g[n - m] % p;&#125;int Lucas(int n, int m, int p)&#123;    if (m == 0)    &#123;        return 1;    &#125;    return Lucas(n / p, m / p, p) * getC(n % p, m % p, p) % p;&#125;\n\n4.高精度加线性筛求组合数（不取模）分解质因数：$C_{n}^{m} &#x3D; p_1^{m_1} \\cdot p_2^{m_2} \\cdot \\cdots \\cdot p_k^{m_k}$其中 $p_1$-$p_k$ 是 $[1,n]$ 中的素数；$m_1$~$m_k$ 是其中对应的每个素数的次数，是在 $n!$ 中的次数减去 $m!$ 中的次数再减去 $(n-m)!$ 中的次数；$n!$ 中 $p$ 的个数：$s &#x3D; \\left\\lfloor \\dfrac{n}{p} \\right\\rfloor + \\left\\lfloor \\dfrac{n}{p^2} \\right\\rfloor + \\left\\lfloor \\dfrac{n}{p^3} \\right\\rfloor + \\cdots$\n\nAcWing 888. 求组合数 IV题目描述输入 $n,m$，求 $C_{n}^{m}$ 的值。注意结果可能很大，需要使用高精度计算。\n输入格式共一行，包含两个整数n和m。\n输出格式共一行，输出$C_{n}^{m}$的值。\n数据范围1≤m≤n≤5000输入样例：\n5 3\n\n输出样例：\n10\n\n代码\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5e3 + 10;int primes[N], vis[N], cnt;int C[N];void get_primes(int n)&#123; // 筛素数    for (int i = 2; i &lt;= n; i++)    &#123;        if (!vis[i])        &#123;            primes[cnt++] = i;        &#125;        for (int j = 0; i * primes[j] &lt;= n; j++)        &#123;            vis[i * primes[j]] = 1;            if (i % primes[j] == 0)            &#123;                break;            &#125;        &#125;    &#125;&#125;int get(int n, int p)&#123; // n!中p的个数    int s = 0;    while (n)    &#123;        s += n / p, n /= p;    &#125;    return s;&#125;int getps(int n, int m, int p)&#123; // C中p的个数    return get(n, p) - get(m, p) - get(n - m, p);&#125;void mul(int C[], int p, int &amp;len)&#123; // 高精度    int t = 0;    for (int i = 0; i &lt; len; i++)    &#123;        t += C[i] * p;        C[i] = t % 10;        t /= 10;    &#125;    while (t)    &#123;        C[len++] = t % 10;        t /= 10;    &#125;&#125;int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    get_primes(n);    int len = 1;    C[0] = 1;    for (int i = 0; i &lt; cnt; i++)    &#123;        int p = primes[i];        int s = getps(n, m, p);        while (s--)        &#123;            mul(C, p, len);        &#125;    &#125;    for (int i = len - 1; i &gt;= 0; i--)    &#123;        cout &lt;&lt; C[i];    &#125;    cout &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n\n#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 5010;int primes[N], cnt;int sum[N];bool st[N];void get_primes(int n)&#123;    for (int i = 2; i &lt;= n; i++)    &#123;        if (!st[i])        &#123;            primes[cnt++] = i;        &#125;        for (int j = 0; primes[j] &lt;= n / i; j++)        &#123;            st[primes[j] * i] = true;            if (i % primes[j] == 0)            &#123;                break;            &#125;        &#125;    &#125;&#125;int get(int n, int p)&#123;    int res = 0;    while (n)    &#123;        res += n / p;        n /= p;    &#125;    return res;&#125;vector&lt;int&gt; mul(vector&lt;int&gt; a, int b)&#123;    vector&lt;int&gt; c;    int t = 0;    for (int i = 0; i &lt; a.size(); i++)    &#123;        t += a[i] * b;        c.push_back(t % 10);        t /= 10;    &#125;    while (t)    &#123;        c.push_back(t % 10);        t /= 10;    &#125;    return c;&#125;int main()&#123;    int n, m;    cin &gt;&gt; n &gt;&gt; m;    get_primes(n);    for (int i = 0; i &lt; cnt; i++)    &#123;        int p = primes[i];        sum[i] = get(n, p) - get(n - m, p) - get(m, p);    &#125;    vector&lt;int&gt; res;    res.push_back(1);    for (int i = 0; i &lt; cnt; i++)    &#123;        for (int j = 0; j &lt; sum[i]; j++)        &#123;            res = mul(res, primes[i]);        &#125;    &#125;    for (int i = res.size() - 1; i &gt;= 0; i--)    &#123;        cout &lt;&lt; res[i];    &#125;    cout &lt;&lt; &#x27;\\n&#x27;;    return 0;&#125;\n","tags":["算法"]}]